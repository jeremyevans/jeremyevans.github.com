<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Eliminating Unnecessary Implicit Allocations</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>

  <link rel="stylesheet" href="./css/reset.css" type="text/css"/>

  <link type="text/css" href="./css/fg.menu.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/theme/ui.all.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/sh_style.css" rel="stylesheet" />
  <link type="text/css" href="./css/tipsy.css" rel="stylesheet" />

  <link rel="stylesheet" href="./css/showoff.css" type="text/css"/>

    <style type="text/css">
      @media screen {
        #preso, .slide {
          width: 1920px;
          height: 1080px;
        }
        #footer { width: 1901px; }
      }
    </style>

  <script type="text/javascript" src="./js/jquery-1.4.2.min.js"></script>
  <script type="text/javascript" src="./js/jquery.cycle.all.js"></script>
	<script type="text/javascript" src="./js/jquery-print.js"></script>
  <script type="text/javascript" src="./js/jquery.batchImageLoad.js"></script>
  <script type="text/javascript" src="./js/jquery.parsequery.min.js"></script>
  <script type="text/javascript" src="./js/jquery.doubletap-0.1.js"></script>
  <script type="text/javascript" src="./js/jquery.tipsy.js"></script>

  <script type="text/javascript" src="./js/fg.menu.js"></script>
  <script type="text/javascript" src="./js/showoff.js"></script>
  <script type="text/javascript" src="./js/jTypeWriter.js"> </script>
  <script type="text/javascript" src="./js/sh_main.min.js"></script>
  <script type="text/javascript" src="./js/core.js"></script>
  <script type="text/javascript" src="./js/showoffcore.js"></script>
  <script type="text/javascript" src="./js/coffee-script.js"></script>

      <script type="text/javascript" src="./js/sh_lang/sh_ruby.min.js"></script>
      <script type="text/javascript" src="./js/sh_lang/sh_c.min.js"></script>
      <script type="text/javascript" src="./js/sh_lang/sh_diff.min.js"></script>

    <link rel="stylesheet" href="./file/fonts.css" type="text/css"/>
    <link rel="stylesheet" href="./file/something.css" type="text/css"/>


  <script type="text/javascript">
  $(function(){
      if(!('slaveWindow' in window) && window.name !== 'toolbar' && $(window).width() < $(document).width()) {
        no_resize = true;
        $('body').css("zoom", ""+($(window).width()*100.0)/$(document).width()+"%");
        $('body').css("overflow-y", "auto");
        $('body').css("overflow-x", "hidden");
        $('#notesInfo').css("font-size", ""+$(document).width()*14.0/$(window).width()+"px");
        $('#notesInfo').css("line-height", ""+$(document).width()*20.0/$(window).width()+"px");
      }
      setupPreso(false, '.');
  });
  </script>

</head>

<body>

<div id="help">
  <table>
    <tr><td class="key">z, ?</td><td>toggle help (this)</td></tr>
    <tr><td class="key">space, &rarr;</td><td>next slide</td></tr>
    <tr><td class="key">shift-space, &larr;</td><td>previous slide</td></tr>
    <tr><td class="key">d</td><td>toggle debug mode</td></tr>
    <tr><td class="key">## &lt;ret&gt;</td><td>go to slide #</td></tr>
    <tr><td class="key">r</td><td>reload slides</td></tr>
    <tr><td class="key">n</td><td>toggle notes</td></tr>
  </table>
</div>

<div class="buttonNav">
  <input type="submit" onClick="prevStep();" value="prev"/>
  <input type="submit" onClick="nextStep();" value="next"/>
</div>

<div id="preso"><center>loading presentation...</center></div>
<div id="footer">
  <span id="notesInfo"></span>
  <img id="disconnected" src="/css/disconnected.png" />
</div>

<div id="slides" class="offscreen" style="display:none;">
<html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/1">
<div class="notes">Hello everyone!  In this presentation, I will be discussing code changes made in Ruby 3.4 to eliminate unnecessary implicit allocations.</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 80px; left: 114px;">Eliminating</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 114px;">Unnecessary</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 114px;">Implicit</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 530px; left: 114px;">Allocations</h1>
<h1 class="blue" style="font-size: 108px; position: absolute; top: 762px; right: 90px; text-align: right;">SF Bay Area <span class="red">Ruby</span> Meetup<br>July 2025</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/2">
<div class="notes">My name is Jeremy Evans. I am a Ruby committer who focuses on fixing bugs in Ruby, and for the last couple years, also on reducing implicit allocations. I'm also the maintainer of Sequel, Roda, and Rodauth. I live up in Sacramento, and thankfully I've been able to make it down here to attend the last few meetups.</div>

<p><img src="./file/jeremy.jpg" class="profile-pic" style="position: absolute; top: 292px; left: 246px;"></p>
<h1 class="red" style="font-size: 72px; position: absolute; top: 432px; left: 750px;">GitHub:  <span class="blue mono"> jeremyevans</span>
</h1>
<h1 class="red" style="font-size: 72px; position: absolute; top: 507px; left: 750px;">Twitter:  <span class="blue mono">@jeremyevans0</span>
</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/3">
<div class="notes">I work at Ubicloud as a Principal Software Engineer.  We are building an open source alternative to Amazon Web Services.</div>

<p><img src="./file/jeremy.jpg" class="profile-pic" style="position: absolute; top: 282px; left: 70px;"></p>
<h1 class="blue" style="font-size: 172px; position: absolute; top: 362px; left: 500px;">@</h1>
<p><img src="./file/ubicloud.svg" style="position: absolute; top: 390px; left: 670px; width: 1180px; height: 149px;"></p>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/4">
<div class="notes">I am going to start this presentation with a discussion on regressions,</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regressions</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/5">
<div class="notes">specifically, allocation regressions.  An allocation regression is a case where Ruby unnecessarily allocates an object in a case where it did not do so previously.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regressions</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/6">
<div class="notes">While working on reducing allocations, in the span of about two weeks, I found and fixed three separate allocation regressions, all of which I caused.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">3 Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regressions</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/7">
<div class="notes">The first allocation regression involved this type of method call, which passes a positional splat, keyword splat, and block.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#1</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>meth(*a, **kw, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/8">
<div class="notes">When I started working on reducing implicit allocations, this allocated 1 array.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#1</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>meth(*a, **kw, &amp;block)


# Ruby 3.3-dev: 1 arrays, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/9">
<div class="notes">I made changes to the optimizer that made this call allocationless.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#1</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>meth(*a, **kw, &amp;block)


# Ruby 3.3-dev: <b>0 arrays</b>, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/10">
<div class="notes">Unfortunately, I found there was an evaluation order issue in this code, if kw was not a hash and block was not a proc,</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#1</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>meth(*a, **<b>kw</b>, &amp;<b>block</b>)


# Ruby 3.3-dev: 0 arrays, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/11">
<div class="notes">as the code would call block.to_proc before kw.to_hash.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#1</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>meth(*a, **kw, &amp;block)
# <b>block.to proc before kw.to_hash</b>

# Ruby 3.3-dev: 0 arrays, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/12">
<div class="notes">I fixed this before the release of Ruby 3.3, so that the code would call kw.to_hash before block.to_proc.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#1</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>meth(*a, **kw, &amp;block)
# <b>kw.to_hash before block.to proc</b>

# Ruby 3.3-dev: 0 arrays, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/13">
<div class="notes">Unfortunately, that broke the optimization, so in Ruby 3.3, this call still allocated an unnecessary array.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#1</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>meth(*a, **kw, &amp;block)
# kw.to_hash before block.to proc

# Ruby 3.3: <b>1 array</b>, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/14">
<div class="notes">I fixed this allocation regression in Ruby 3.4, so this call is once again allocationless.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#1</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>meth(*a, **kw, &amp;block)
# kw.to_hash before block.to proc

# Ruby 3.3: 1 arrays, 0 hashes
# Ruby 3.4: 0 arrays, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/15">
<div class="notes">The second allocation regression affected this code.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#2</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
hash = {a: 10}
foo(**hash)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/16">
<div class="notes">Here we have a method that accepts a keyword argument.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#2</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def <b>foo(a:)</b> = a
hash = {a: 10}
foo(**hash)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/17">
<div class="notes">We are calling the method with a keyword splat.  This should not require an allocation, because we can just look into the keyword splat hash to get the value.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#2</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
hash = {a: 10}
<b>foo(**hash)</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/18">
<div class="notes">Indeed, in Ruby 3.2, this call was allocationless. In Ruby 3.3, I fixed a bug that passed the keyword splat directly as a positional argument, instead of passing a copy of the keyword splat, if the calling method did not accept keywords.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#2</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
hash = {a: 10}
<b>foo(**hash)</b>

# Ruby 3.2: 0 arrays, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/19">
<div class="notes">Unfortunately, that bug fix caused an allocation regression, resulting in this code allocating a hash.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#2</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
hash = {a: 10}
<b>foo(**hash)</b>

# Ruby 3.2: 0 arrays, 0 hashes
# Ruby 3.3: 0 arrays, <b>1 hashes</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/20">
<div class="notes">I fixed this regression in Ruby 3.4, so this type of call is once again allocationless.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#2</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
hash = {a: 10}
<b>foo(**hash)</b>

# Ruby 3.2: 0 arrays, 0 hashes
# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4: 0 arrays, 0 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/21">
<div class="notes">The third allocation regression involved this type of call.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(*a, a: 1)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/22">
<div class="notes">We have the same method as in the previous example,</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code><b>def foo(a:) = a</b>
array = []
foo(*a, a: 1)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/23">
<div class="notes">but this time, we are calling it with a positional splat and static literal keywords.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(<b>*a, a: 1</b>)

</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/24">
<div class="notes">This allocates a single hash in Ruby 3.3.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(*a, a: 1)

# Ruby 3.3: 0 arrays, 1 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/25">
<div class="notes">When adding a optimization early in the Ruby 3.4 development cycle, I introduced an allocation regression, and made this call allocate an array as well as a hash.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(*a, a: 1)

# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4-dev: <b>1 arrays</b>, 1 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/26">
<div class="notes">The cause of this allocation regression was a mistake I made when refactoring a different optimization.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_c" style="font-size: 32px; margin-top: 428px; margin-left: 0;"><code>
if (optimize_args_splat_no_copy(iseq, iobj, niobj-&gt;next,
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/27">
<div class="notes">I added an optimize_args_splat_no_copy function to remove redundancy in 6 other allocation reduction optimizations I made using the optimzer.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_c" style="font-size: 32px; margin-top: 428px; margin-left: 0;"><code>
if (<b>optimize_args_splat_no_copy</b>(iseq, iobj, niobj-&gt;next,
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/28">
<div class="notes">When refactoring the optimizer code to use this function, I passed the wrong instruction to the function.  This did not cause any detectable problems, it just meant the optimizer no longer recognized this instruction combination as an optimizable case.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_diff" style="font-size: 32px; margin-top: 428px; margin-left: 0;"><code>
if (optimize_args_splat_no_copy(iseq, iobj, <b>niobj-&gt;next</b>,
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/29">
<div class="notes">Passing the correct instruction allowed the optimize_args_splat_no_copy function to recognize this as an optimizable case.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_diff" style="font-size: 32px; margin-top: 428px; margin-left: 0;"><code>
if (optimize_args_splat_no_copy(iseq, iobj, <b>niobj</b>,
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/30">
<div class="notes">That fixed the regression, so the code no longer allocated an unnecessary array.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(*a, a: 1)

# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4-dev: <b>0 arrays</b>, 1 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/31">
<div class="notes">It still allocated a hash though, and I decided to see if that allocation could be eliminated.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(*a, a: 1)

# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4-dev: 0 arrays, <b>1 hashes</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/32">
<div class="notes">Unfortunately, Ruby's internal method calling API does not support literal keywords following a positional splat. So if you use literal keywords following a positional splat,</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(<b>*a, a: 1</b>)

# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4-dev: 0 arrays, 1 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/33">
<div class="notes">Ruby will implicitly turn this into a keyword splat.  Since a keyword splat requires a hash, using literal keywords after a positional splat generally requires a hash allocation.|However, in this case, the hash needed does not depend on external code.  All keys and values in the hash are immutable literals.  This allows you to use pass a shared frozen hash instead of a allocating a new hash.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(*a, <b>**{a: 1}</b>)

# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4-dev: 0 arrays, 1 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/34">
<div class="notes">This would be equivalent of creating a constant storing the frozen hash,</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []; <b>SHARED_HASH = {a: 1}.freeze</b>
foo(*a, **{a: 1})

# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4-dev: 0 arrays, 1 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/35">
<div class="notes">and the using that constant as the keyword splat hash. The only difference is that instead of a constant, this uses a frozen hash that is inlined into the virtual machine instructions.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []; SHARED_HASH = {a: 1}.freeze
foo(*a, **<b>SHARED_HASH</b>)

# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4-dev: 0 arrays, 1 hashes
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/36">
<div class="notes">Let's look at the simplified virtual machine instructions for this method call in Ruby 3.3:</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>a = []
foo(*a, a: 1)
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>new_array
setlocal_WC_0  a@0
putself
getlocal_WC_0  a@0
splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2
leave
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/37">
<div class="notes">The first two instructions create a new array and assign it to a local variable.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code><b>a = []</b>
foo(*a, a: 1)
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code><b class="block">new_array
setlocal_WC_0  a@0</b>
putself
getlocal_WC_0  a@0
splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2
leave
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/38">
<div class="notes">These two instructions implement the positional splat.  First, we get the value of the local variable, then we use the splatarray instruction to convert it to an array if it is not already an array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>a = []
foo(<b>*a</b>, a: 1)
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>new_array
setlocal_WC_0  a@0
putself
<b class="block">getlocal_WC_0  a@0
splatarray     false</b>
duphash        {:a=&gt;1}
send           #foo, argc:2
leave
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/39">
<div class="notes">The false argument to the splatarray instruction tells the instruction to not duplicate the object being splatted if it is already an array.  Using the false argument to splatarray is an optimization I added in Ruby 3.3 to avoid an array allocation for this type of method call.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>a = []
foo(*a, a: 1)
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>new_array
setlocal_WC_0  a@0
putself
getlocal_WC_0  a@0
splatarray     <b>false</b>
duphash        {:a=&gt;1}
send           #foo, argc:2
leave
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/40">
<div class="notes">This is the instruction that sets up the keyword splat hash for the implicit keyword splat.  As you can guess by the duphash instruction name, this duplicates an existing hash, which is what caused this method call to allocate an unnecessary hash.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>a = []
foo(*a, <b>a: 1</b>)
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>new_array
setlocal_WC_0  a@0
putself
getlocal_WC_0  a@0
splatarray     false
<b>duphash        {:a=&gt;1}</b>
send           #foo, argc:2
leave
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/41">
<div class="notes">To avoid the unnecessary hash allocation, we need to change the instruction to use putobject. putobject will push the hash onto the VM stack without copying it.  This is safe as long as the hash is frozen.  The hash currently isn't frozen, so we need to fix that when we implement the optimization.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>a = []
foo(*a, a: 1)
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>new_array
setlocal_WC_0  a@0
putself
getlocal_WC_0  a@0
splatarray     false
<b>putobject</b>      {:a=&gt;1}
send           #foo, argc:2
leave
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/42">
<div class="notes">We'll implement this optimization using the peephole optimizer.  The peephole optimizer is one of the optimization passes Ruby uses for VM instructions.  It goes through each instruction, looking for specific patterns in the current instruction and following instructions. If it finds a pattern it recognizes, it modifies the instructions to use more optimized code.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>    if (IS_INSN_ID(iobj, splatarray) &amp;&amp; OPERAND_AT(iobj, 0) == false) {
        LINK_ELEMENT *niobj = &amp;iobj-&gt;link;
        if (IS_NEXT_INSN_ID(niobj, duphash)) {
            niobj = niobj-&gt;next;
            LINK_ELEMENT *siobj;
            unsigned int set_flags = 0, unset_flags = 0;

            if (IS_NEXT_INSN_ID(niobj, send)) {
                siobj = niobj-&gt;next;
                set_flags = VM_CALL_ARGS_SPLAT|VM_CALL_KW_SPLAT|VM_CALL_KW_SPLAT_MUT;
                unset_flags = VM_CALL_ARGS_BLOCKARG;
            }
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/43">
<div class="notes">We start the optimization by looking for splatarray instructions with false arguments</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>    if (IS_INSN_ID(iobj, <b>splatarray</b>) &amp;&amp; OPERAND_AT(iobj, 0) == <b>false</b>) {
        LINK_ELEMENT *niobj = &amp;iobj-&gt;link;
        if (IS_NEXT_INSN_ID(niobj, duphash)) {
            niobj = niobj-&gt;next;
            LINK_ELEMENT *siobj;
            unsigned int set_flags = 0, unset_flags = 0;

            if (IS_NEXT_INSN_ID(niobj, send)) {
                siobj = niobj-&gt;next;
                set_flags = VM_CALL_ARGS_SPLAT|VM_CALL_KW_SPLAT|VM_CALL_KW_SPLAT_MUT;
                unset_flags = VM_CALL_ARGS_BLOCKARG;
            }
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code><b>splatarray     false</b>
duphash        {:a=&gt;1}
send           #foo, argc:2
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/44">
<div class="notes">We only want this optimization to affect cases where the splatarray false instruction is immediately followed by a duphash instruction.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>    if (IS_INSN_ID(iobj, splatarray) &amp;&amp; OPERAND_AT(iobj, 0) == false) {
        LINK_ELEMENT *niobj = &amp;iobj-&gt;link;
        if (<b>IS_NEXT_INSN_ID(niobj, duphash)</b>) {
            niobj = niobj-&gt;next;
            LINK_ELEMENT *siobj;
            unsigned int set_flags = 0, unset_flags = 0;

            if (IS_NEXT_INSN_ID(niobj, send)) {
                siobj = niobj-&gt;next;
                set_flags = VM_CALL_ARGS_SPLAT|VM_CALL_KW_SPLAT|VM_CALL_KW_SPLAT_MUT;
                unset_flags = VM_CALL_ARGS_BLOCKARG;
            }
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
<b>duphash        {:a=&gt;1}</b>
send           #foo, argc:2
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/45">
<div class="notes">We then check that the instruction after the duphash instruction is send. If so, this may be a case we can optimize.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>    if (IS_INSN_ID(iobj, splatarray) &amp;&amp; OPERAND_AT(iobj, 0) == false) {
        LINK_ELEMENT *niobj = &amp;iobj-&gt;link;
        if (IS_NEXT_INSN_ID(niobj, duphash)) {
            niobj = niobj-&gt;next;
            LINK_ELEMENT *siobj;
            unsigned int set_flags = 0, unset_flags = 0;

            if (IS_NEXT_INSN_ID(niobj, <b>send</b>)) {
                siobj = niobj-&gt;next;
                set_flags = VM_CALL_ARGS_SPLAT|VM_CALL_KW_SPLAT|VM_CALL_KW_SPLAT_MUT;
                unset_flags = VM_CALL_ARGS_BLOCKARG;
            }
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
duphash        {:a=&gt;1}
<b>send</b>           #foo, argc:2
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/46">
<div class="notes">In order to be optimized, it must have the following method call flags set. ARGS_SPLAT means the method call has a positional splat. KW_SPLAT means the method call has a keyword splat.  KW_SPLAT_MUT means that the keyword splat is mutable.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>    if (IS_INSN_ID(iobj, splatarray) &amp;&amp; OPERAND_AT(iobj, 0) == false) {
        LINK_ELEMENT *niobj = &amp;iobj-&gt;link;
        if (IS_NEXT_INSN_ID(niobj, duphash)) {
            niobj = niobj-&gt;next;
            LINK_ELEMENT *siobj;
            unsigned int set_flags = 0, unset_flags = 0;

            if (IS_NEXT_INSN_ID(niobj, send)) {
                siobj = niobj-&gt;next;
                set_flags = <b>VM_CALL_ARGS_SPLAT|VM_CALL_KW_SPLAT|VM_CALL_KW_SPLAT_MUT</b>;
                unset_flags = VM_CALL_ARGS_BLOCKARG;
            }
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/47">
<div class="notes">Additionally, for the optimization to be valid, the method must not be passing a block using ampersand, so it cannot have the ARGS_BLOCKARG method call flag.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>    if (IS_INSN_ID(iobj, splatarray) &amp;&amp; OPERAND_AT(iobj, 0) == false) {
        LINK_ELEMENT *niobj = &amp;iobj-&gt;link;
        if (IS_NEXT_INSN_ID(niobj, duphash)) {
            niobj = niobj-&gt;next;
            LINK_ELEMENT *siobj;
            unsigned int set_flags = 0, unset_flags = 0;

            if (IS_NEXT_INSN_ID(niobj, send)) {
                siobj = niobj-&gt;next;
                set_flags = VM_CALL_ARGS_SPLAT|VM_CALL_KW_SPLAT|VM_CALL_KW_SPLAT_MUT;
                unset_flags = <b>VM_CALL_ARGS_BLOCKARG</b>;
            }
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/48">
<div class="notes">I omitted the method call flags when showing the virtual machine instructions, but here's what they are.  This has the ARGS_SPLAT, KW_SPLAT, and KW_SPLAT_MUT method call flags set, and does not have the ARGS_BLOCKARG flag set, so it is a candidate for optimization.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>    if (IS_INSN_ID(iobj, splatarray) &amp;&amp; OPERAND_AT(iobj, 0) == false) {
        LINK_ELEMENT *niobj = &amp;iobj-&gt;link;
        if (IS_NEXT_INSN_ID(niobj, duphash)) {
            niobj = niobj-&gt;next;
            LINK_ELEMENT *siobj;
            unsigned int set_flags = 0, unset_flags = 0;

            if (IS_NEXT_INSN_ID(niobj, send)) {
                siobj = niobj-&gt;next;
                set_flags = <b>VM_CALL_ARGS_SPLAT|VM_CALL_KW_SPLAT|VM_CALL_KW_SPLAT_MUT</b>;
                unset_flags = <b>VM_CALL_ARGS_BLOCKARG</b>;
            }
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2,
      <b>ARGS_SPLAT|FCALL|KW_SPLAT|KW_SPLAT_MUT</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/49">
<div class="notes">This is the part of the code that actually implements the optimization.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>
if (set_flags) {
    const struct rb_callinfo *ci = (const struct rb_callinfo *)OPERAND_AT(siobj, 0);
    unsigned int flags = vm_ci_flag(ci);
    if ((flags &amp; set_flags) == set_flags &amp;&amp; !(flags &amp; unset_flags)) {
        ((INSN*)niobj)-&gt;insn_id = BIN(putobject);
        RB_OBJ_WRITE(iseq, &amp;OPERAND_AT(niobj, 0),
            rb_hash_freeze(rb_hash_resurrect(OPERAND_AT(niobj, 0))));

        const struct rb_callinfo *nci = vm_ci_new(vm_ci_mid(ci),
            flags &amp; ~VM_CALL_KW_SPLAT_MUT, vm_ci_argc(ci), vm_ci_kwarg(ci));
        RB_OBJ_WRITTEN(iseq, ci, nci);
        OPERAND_AT(siobj, 0) = (VALUE)nci;
    }
}
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2,
      ARGS_SPLAT|FCALL|KW_SPLAT|KW_SPLAT_MUT
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/50">
<div class="notes">We first get access to the existing method call flags from the appropriate instruction object.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>
if (set_flags) {
<b class="block">    const struct rb_callinfo *ci = (const struct rb_callinfo *)OPERAND_AT(siobj, 0);
    unsigned int flags = vm_ci_flag(ci);</b>
    if ((flags &amp; set_flags) == set_flags &amp;&amp; !(flags &amp; unset_flags)) {
        ((INSN*)niobj)-&gt;insn_id = BIN(putobject);
        RB_OBJ_WRITE(iseq, &amp;OPERAND_AT(niobj, 0),
            rb_hash_freeze(rb_hash_resurrect(OPERAND_AT(niobj, 0))));

        const struct rb_callinfo *nci = vm_ci_new(vm_ci_mid(ci),
            flags &amp; ~VM_CALL_KW_SPLAT_MUT, vm_ci_argc(ci), vm_ci_kwarg(ci));
        RB_OBJ_WRITTEN(iseq, ci, nci);
        OPERAND_AT(siobj, 0) = (VALUE)nci;
    }
}
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2,
      ARGS_SPLAT|FCALL|KW_SPLAT|KW_SPLAT_MUT
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/51">
<div class="notes">We check that the necessary method call flags are set, and the method call flags that are required not to be present are not set.  If so, all checks are successful and we can proceed to the optimization.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>
if (set_flags) {
    const struct rb_callinfo *ci = (const struct rb_callinfo *)OPERAND_AT(siobj, 0);
    unsigned int flags = vm_ci_flag(ci);
    if (<b>(flags &amp; set_flags) == set_flags</b> &amp;&amp; <b>!(flags &amp; unset_flags)</b>) {
        ((INSN*)niobj)-&gt;insn_id = BIN(putobject);
        RB_OBJ_WRITE(iseq, &amp;OPERAND_AT(niobj, 0),
            rb_hash_freeze(rb_hash_resurrect(OPERAND_AT(niobj, 0))));

        const struct rb_callinfo *nci = vm_ci_new(vm_ci_mid(ci),
            flags &amp; ~VM_CALL_KW_SPLAT_MUT, vm_ci_argc(ci), vm_ci_kwarg(ci));
        RB_OBJ_WRITTEN(iseq, ci, nci);
        OPERAND_AT(siobj, 0) = (VALUE)nci;
    }
}
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
duphash        {:a=&gt;1}
send           #foo, argc:2,
      ARGS_SPLAT|FCALL|KW_SPLAT|KW_SPLAT_MUT
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/52">
<div class="notes">We change the duphash instruction to be a pubobject instruction.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>
if (set_flags) {
    const struct rb_callinfo *ci = (const struct rb_callinfo *)OPERAND_AT(siobj, 0);
    unsigned int flags = vm_ci_flag(ci);
    if ((flags &amp; set_flags) == set_flags &amp;&amp; !(flags &amp; unset_flags)) {
        <b>((INSN*)niobj)-&gt;insn_id = BIN(putobject);</b>
        RB_OBJ_WRITE(iseq, &amp;OPERAND_AT(niobj, 0),
            rb_hash_freeze(rb_hash_resurrect(OPERAND_AT(niobj, 0))));

        const struct rb_callinfo *nci = vm_ci_new(vm_ci_mid(ci),
            flags &amp; ~VM_CALL_KW_SPLAT_MUT, vm_ci_argc(ci), vm_ci_kwarg(ci));
        RB_OBJ_WRITTEN(iseq, ci, nci);
        OPERAND_AT(siobj, 0) = (VALUE)nci;
    }
}
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
<b>putobject</b>      {:a=&gt;1}
send           #foo, argc:2,
      ARGS_SPLAT|FCALL|KW_SPLAT|KW_SPLAT_MUT
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/53">
<div class="notes">The instruction output doesn't show it, but the duphash instruction argument is not frozen.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>
if (set_flags) {
    const struct rb_callinfo *ci = (const struct rb_callinfo *)OPERAND_AT(siobj, 0);
    unsigned int flags = vm_ci_flag(ci);
    if ((flags &amp; set_flags) == set_flags &amp;&amp; !(flags &amp; unset_flags)) {
        ((INSN*)niobj)-&gt;insn_id = BIN(putobject);
        RB_OBJ_WRITE(iseq, &amp;OPERAND_AT(niobj, 0),
            rb_hash_freeze(rb_hash_resurrect(OPERAND_AT(niobj, 0))));

        const struct rb_callinfo *nci = vm_ci_new(vm_ci_mid(ci),
            flags &amp; ~VM_CALL_KW_SPLAT_MUT, vm_ci_argc(ci), vm_ci_kwarg(ci));
        RB_OBJ_WRITTEN(iseq, ci, nci);
        OPERAND_AT(siobj, 0) = (VALUE)nci;
    }
}
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
putobject      <b>{:a=&gt;1}</b>
send           #foo, argc:2,
      ARGS_SPLAT|FCALL|KW_SPLAT|KW_SPLAT_MUT
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/54">
<div class="notes">Because the putobject instruction argument instruction must be frozen, as the same hash will be used for all calls, we make a copy of the existing hash using rb_hash_resurrect, and then freeze that hash with rb_hash_freeze.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>
if (set_flags) {
    const struct rb_callinfo *ci = (const struct rb_callinfo *)OPERAND_AT(siobj, 0);
    unsigned int flags = vm_ci_flag(ci);
    if ((flags &amp; set_flags) == set_flags &amp;&amp; !(flags &amp; unset_flags)) {
        ((INSN*)niobj)-&gt;insn_id = BIN(putobject);
        RB_OBJ_WRITE(iseq, &amp;OPERAND_AT(niobj, 0),
            <b>rb_hash_freeze(rb_hash_resurrect(OPERAND_AT(niobj, 0))));</b>

        const struct rb_callinfo *nci = vm_ci_new(vm_ci_mid(ci),
            flags &amp; ~VM_CALL_KW_SPLAT_MUT, vm_ci_argc(ci), vm_ci_kwarg(ci));
        RB_OBJ_WRITTEN(iseq, ci, nci);
        OPERAND_AT(siobj, 0) = (VALUE)nci;
    }
}
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
putobject      {:a=&gt;1}
send           #foo, argc:2,
      ARGS_SPLAT|FCALL|KW_SPLAT|KW_SPLAT_MUT
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/55">
<div class="notes">Obviously, a frozen object cannot be mutable, so the KW_SPLAT_MUT keyword flag is invalid.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>
if (set_flags) {
    const struct rb_callinfo *ci = (const struct rb_callinfo *)OPERAND_AT(siobj, 0);
    unsigned int flags = vm_ci_flag(ci);
    if ((flags &amp; set_flags) == set_flags &amp;&amp; !(flags &amp; unset_flags)) {
        ((INSN*)niobj)-&gt;insn_id = BIN(putobject);
        RB_OBJ_WRITE(iseq, &amp;OPERAND_AT(niobj, 0),
            rb_hash_freeze(rb_hash_resurrect(OPERAND_AT(niobj, 0))));

        const struct rb_callinfo *nci = vm_ci_new(vm_ci_mid(ci),
            flags &amp; ~VM_CALL_KW_SPLAT_MUT, vm_ci_argc(ci), vm_ci_kwarg(ci));
        RB_OBJ_WRITTEN(iseq, ci, nci);
        OPERAND_AT(siobj, 0) = (VALUE)nci;
    }
}
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
putobject      {:a=&gt;1}
send           #foo, argc:2,
      ARGS_SPLAT|FCALL|KW_SPLAT|<b>KW_SPLAT_MUT</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/56">
<div class="notes">So we unset that method call flag. This completes the optimization.</div>

<pre class="sh_ruby" style="font-size: 32px; margin-top: 28px; margin-left: 30px;"><code>
if (set_flags) {
    const struct rb_callinfo *ci = (const struct rb_callinfo *)OPERAND_AT(siobj, 0);
    unsigned int flags = vm_ci_flag(ci);
    if ((flags &amp; set_flags) == set_flags &amp;&amp; !(flags &amp; unset_flags)) {
        ((INSN*)niobj)-&gt;insn_id = BIN(putobject);
        RB_OBJ_WRITE(iseq, &amp;OPERAND_AT(niobj, 0),
            rb_hash_freeze(rb_hash_resurrect(OPERAND_AT(niobj, 0))));

        const struct rb_callinfo *nci = vm_ci_new(vm_ci_mid(ci),
            <b>flags &amp; ~VM_CALL_KW_SPLAT_MUT</b>, vm_ci_argc(ci), vm_ci_kwarg(ci));
        RB_OBJ_WRITTEN(iseq, ci, nci);
        OPERAND_AT(siobj, 0) = (VALUE)nci;
    }
}
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 680px; position: absolute"><code>splatarray     false
putobject      {:a=&gt;1}
send           #foo, argc:2,
      ARGS_SPLAT|FCALL|KW_SPLAT
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/57">
<div class="notes">That means that this call is now allocationless in Ruby 3.4.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regression <span class="blue">#3</span>
</h1>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 428px; margin-left: 100px;"><code>def foo(a:) = a
array = []
foo(*a, a: 1)

# Ruby 3.3: 0 arrays, 1 hashes
# Ruby 3.4: 0 arrays, <b>0 hashes</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/58">
<div class="notes">As I mentioned, I found and fixed these three allocation regressions within about two weeks.  Finding multiple allocation regressions in so short a timeframe was disheartening. It indicated to me that there was little point in attempting to eliminate unnecessary allocations, unless I could prevent future allocation regressions.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; right: 744px;">3 Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regressions</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/59">
<div class="notes">So I thought about how to do that. The conclusion I came to is that allocation regressions are no different in nature than any other regressions. And how do you avoid regressions generally?</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 20px; left: 324px;">How To Avoid</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 170px; left: 324px;">Regressions<span class="blue">?</span>
</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/60">
<div class="notes">Well, you add tests.  Tests help you ensure expected behavior.</div>

<h1 class="red" style="font-size: 360px; position: absolute; top: 320px; left: 344px;">Tests</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/61">
<div class="notes">If the expected behavior is that a certain type of method call allocates a certain number of objects, you need to write a test for that.  That way, if you change the code and it results in an allocation regression, the related test breaks, alerting you to the problem immediately, and allowing you to fix it.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 344px;">Allocation</h1>
<h1 class="red" style="font-size: 360px; position: absolute; top: 320px; left: 344px;">Tests</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/62">
<div class="notes">So I started writing an allocation test suite.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 344px;">Allocation</h1>
<h1 class="red" style="font-size: 360px; position: absolute; top: 320px; left: 344px;">Test</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 490px; left: 1064px;">Suite</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/63">
<div class="notes">As I have limited time, I am not going to discuss the implementation of the allocation test suite, but I will go over a simplified example of an allocation test.  In this allocation test, we define a method.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 228px; margin-left: 100px;"><code>def required(x); end
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/64">
<div class="notes">Then we call the check_allocations method.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 228px; margin-left: 100px;"><code>def required(x); end

check_allocations(0, 0, "required(1)")
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/65">
<div class="notes">The third argument is the code that will be executed.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 228px; margin-left: 100px;"><code>def required(x); end

check_allocations(0, 0, <b>"required(1)"</b>)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/66">
<div class="notes">The first argument is the number of arrays the code should allocate.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 228px; margin-left: 100px;"><code>def required(x); end

check_allocations(<b>0</b>, 0, "required(1)")
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/67">
<div class="notes">The second argument is the number of hashes the code should allocate.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 228px; margin-left: 100px;"><code>def required(x); end

check_allocations(0, <b>0</b>, "required(1)")
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/68">
<div class="notes">So this line tests that calling a method that has a single positional parameter with a single positional argument should not allocate an array or a hash.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 228px; margin-left: 100px;"><code>def required(x); end

<b>check_allocations(0, 0, "required(1)")</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/69">
<div class="notes">This line tests that calling the same method with a keyword splat does not allocate an array, but does allocate one hash.  This is expected, as the positional parameter should be passed a copy of the keyword splat hash.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 228px; margin-left: 100px;"><code>def required(x); end

check_allocations(0, 0, "required(1)")
<b>check_allocations(0, 1, "required(**hash")</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/70">
<div class="notes">I think the allocation test suite I created was my most important contribution to Ruby 3.4. It resulted in 3 major benefits.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 344px;">Allocation</h1>
<h1 class="red" style="font-size: 360px; position: absolute; top: 320px; left: 344px;">Test</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 490px; left: 1064px;">Suite</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/71">
<div class="notes">The first benefit is that since its introduction, it has prevented further allocation regressions, at least for the cases it tests.</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 70px; left: 344px;">Prevent</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 344px;">Allocation</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 344px;">Regressions</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/72">
<div class="notes">The second benefit was that it allowed the Prism team to find all of the tested cases where the Prism compiler was allocating more objects than the parse.y compiler, and fix all of those cases before Prism was made the default parser.  This prevented allocation regressions from the parser switch.</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 573px; left: 714px;">Prism</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/73">
<div class="notes">Finally, the test suite shows for each type of call, how many implicit allocations the call was making.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 114px;">Shows</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 114px;">Implicit</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 530px; left: 114px;">Allocations</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/74">
<div class="notes">I could review the allocation numbers for a passing allocation test suite, and find cases where Ruby was unnecessarily allocating objects.</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 80px; left: 114px;">Determine</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 114px;">Unnecessary</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 114px;">Implicit</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 530px; left: 114px;">Allocations</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/75">
<div class="notes">The allocation test suite basically provided me a list of call types where I could eliminate unnecessary implicit allocations.</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 80px; left: 114px;">Eliminating</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 114px;">Unnecessary</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 114px;">Implicit</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 530px; left: 114px;">Allocations</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/76">
<div class="notes">Note that not all unnecessary implicit allocations were in method calling.  I found that large literal arrays can allocate more than one array.</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 270px; left: 514px;">Large</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 420px; left: 514px;">Literal</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 563px; left: 514px;">Arrays</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/77">
<div class="notes">For some background, I will give a brief overview of the VM instructions used to create literal arrays in Ruby.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 420px; left: 514px;">Literal</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 563px; left: 514px;">Arrays</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/78">
<div class="notes">The empty literal array allocates one array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>[]
# 1 array
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/79">
<div class="notes">This is implemented using a single VM instruction, newarray 0.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>[]
# 1 array
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>newarray       0
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/80">
<div class="notes">If an array contains only other frozen literals, such as numbers and symbols, it also only allocates 1 array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>[1]
# 1 array
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/81">
<div class="notes">In this case, a hidden array is statically allocated for the literal, and the duparray instruction is used, which returns a copy of the array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>[1]
# 1 array
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>duparray       [1]
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/82">
<div class="notes">This is true regardless of the size of the array, as long as all elements are frozen literals.  Even if the literal array has a million elements, it only allocates one array,</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>[1, 2, ..., 1_000_000]
# 1 array
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/83">
<div class="notes">because a single duparray instruction is still used, which returns a copy of the hidden array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>[1, 2, ..., 1_000_000]
# 1 array
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>duparray       [1, 2, ..., 1_000_000]
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/84">
<div class="notes">In Ruby 3.3, if the literal array contains a non-frozen literal or an expression, the number of array allocations is based on the number of elements in the array.  Here we have an array created with a single local variable.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v]
# 1 array
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/85">
<div class="notes">This literal array will be created using two instructions</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v]
# 1 array
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
newarray       1
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/86">
<div class="notes">The first instruction will retrive the value of the local variable, and place it on the VM stack.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v]
# 1 array
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code><b>getlocal_WC_0  v@0</b>
newarray       1
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/87">
<div class="notes">The second instruction will allocate a new array with a single element, using the top element on the VM stack.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v]
# 1 array
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
<b>newarray       1</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/88">
<div class="notes">Here is a more complex case, a literal array with 257 elements, all of which are local variable accesses.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/89">
<div class="notes">This is a case that actually allocates more than 1 array in Ruby 3.3.  It allocates 3 arrays.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/90">
<div class="notes">Here are the VM instructions used.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       256
getlocal_WC_0  v@0
newarray       1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/91">
<div class="notes">The first 256 instructions just retrieve the local variable value and push it onto the VM stack.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code><b class="block">getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0</b>
newarray       256
getlocal_WC_0  v@0
newarray       1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/92">
<div class="notes">Then it creates one array with 256 elements. This is the first array allocation.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
<b>newarray       256</b>
getlocal_WC_0  v@0
newarray       1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/93">
<div class="notes">This instruction is the same as the earlier instructions, and pushes the local variable value onto the VM stack.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       256
<b>getlocal_WC_0  v@0</b>
newarray       1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/94">
<div class="notes">This newarray instruction allocates another array to wrap that element, which is the second array allocation.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       256
getlocal_WC_0  v@0
<b>newarray       1</b>
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/95">
<div class="notes">The final instruction is a concatarray instruction, which takes the 2 temporary arrays, and combines them, returning a newly allocated array.  This is the third array allocation.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       256
getlocal_WC_0  v@0
newarray       1
<b>concatarray</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/96">
<div class="notes">I am guessing that a lot of you may be wondering why Ruby allocates a new array for every 256 elements.  It certainly was not obvious to me when I first started looking at this code.  It turns out the reason Ruby does this is to avoid VM stack overflow.|The VM stack has a limited size, and if you tried to define a large enough literal array, you could overflow the VM stack. To avoid that, starting in Ruby 2.0, Ruby chunks large literal arrays into sub arrays of 256 elements, then concatenates them together.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       <b>256</b>
getlocal_WC_0  v@0
newarray       1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/97">
<div class="notes"> If you try to create a literal array with a million local variable elements on Ruby 1.9</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # <b>1 million times</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/98">
<div class="notes">you will get a SystemStackError.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 1 million times
<b>SystemStackError</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/99">
<div class="notes">So this chunking in 256 elements seems reasonable, as you definitely want to avoid VM stack overflow.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       256
getlocal_WC_0  v@0
newarray       1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/100">
<div class="notes">That being said, while this array allocation seems necessary, since a literal array must allocate at least one array,</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
<b>newarray       256</b>
getlocal_WC_0  v@0
newarray       1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/101">
<div class="notes">these two array allocations seem unnecessary. Instead of allocating new arrays, we should append to the array allocated in the newarray 256 instruction.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       256
getlocal_WC_0  v@0
<b class="block">newarray       1
concatarray</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/102">
<div class="notes">We can do that using a VM instruction I added near the start of the Ruby 3.4 development cycle. I added the instruction to reduce allocations in this type of method call.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>a(*ary, ary)
# 3 arrays
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/103">
<div class="notes">The instructions for the caller-side argument setup for this method call used the same two instructions, newarray followed by concat array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>a(*ary, ary)
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  ary@0
splatarray     true
getlocal_WC_0  ary@0
<b class="block">newarray       1
concatarray</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/104">
<div class="notes">I eliminated both of the array allocations using a new VM instruction, pushtoarray, which pops the given number of elements off the VM stack, and then pushes them onto the array then at the top of the VM stack.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>a(*ary, ary)
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  ary@0
splatarray     true
getlocal_WC_0  ary@0
<b>pushtoarray    1</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/105">
<div class="notes">We can optimize literal arrays using the same pushtoarray instruction. This avoids both array allocations.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       256
getlocal_WC_0  v@0
<b>pushtoarray    1</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/106">
<div class="notes">That change means that this literal array only allocates a single array in Ruby 3.4.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = 1
[v, v, ..., v] # 257 times
# <b>1 array</b>
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
getlocal_WC_0  v@0
# 253 more times
getlocal_WC_0  v@0
newarray       256
getlocal_WC_0  v@0
pushtoarray    1
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/107">
<div class="notes">It turns out it was not just large literal arrays that allocated more than one array in Ruby 3.3.</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 270px; left: 514px;">Large</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 420px; left: 514px;">Literal</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 563px; left: 514px;">Arrays</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/108">
<div class="notes">Literal arrays that contained positional splats also allocate more than one array in Ruby 3.3.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 420px; left: 514px;">Literal</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 563px; left: 514px;">Arrays</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 710px; left: 534px;">with Splats</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/109">
<div class="notes">For example, this literal array, which contains a single splat.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
<b>[v, *v, v]</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/110">
<div class="notes">Allocates 4 arrays in Ruby 3.3.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, *v, v]
# <b>4 arrays</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/111">
<div class="notes">Here are the instructions used to create the literal array in Ruby 3.3.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, *v, v]
# 4 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
newarray       1
getlocal_WC_0  v@0
concatarray
getlocal_WC_0  v@0
newarray       1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/112">
<div class="notes">All four of these instructions allocate an array, even though only one array allocation is needed.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, *v, v]
# 4 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
<b>newarray       1</b>
getlocal_WC_0  v@0
<b>concatarray</b>
getlocal_WC_0  v@0
<b class="block">newarray       1
concatarray</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/113">
<div class="notes">Switching the final newarray and concatarray instructions to pushtoarray eliminates 2 array allocations.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, *v, v]
# 4 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
newarray       1
getlocal_WC_0  v@0
concatarray
getlocal_WC_0  v@0
<b>pushtoarray    1</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/114">
<div class="notes">The final unnecessary allocation is due to this concatarray instruction,</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, *v, v]
# 4 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
newarray       1
getlocal_WC_0  v@0
<b>concatarray</b>
getlocal_WC_0  v@0
pushtoarray    1
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/115">
<div class="notes">which is used to implement the splat part of the literal array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, <b>*v</b>, v]
# 4 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
newarray       1
getlocal_WC_0  v@0
<b>concatarray</b>
getlocal_WC_0  v@0
pushtoarray    1
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/116">
<div class="notes">This is fixed by using another new VM instruction I added to optimize method calls, which is called concattoarray.  This instruction is similar to concatarray, but it does not allocate a new array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, *v, v]
# 4 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
newarray       1
getlocal_WC_0  v@0
<b>concattoarray</b>
getlocal_WC_0  v@0
pushtoarray    1
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/117">
<div class="notes">With these two changes,</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, *v, v]
# 4 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
newarray       1
getlocal_WC_0  v@0
<b>concattoarray</b>
getlocal_WC_0  v@0
<b>pushtoarray    1</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/118">
<div class="notes">Ruby 3.4 now only allocates a single array when creating a literal array with splats.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
[v, *v, v]
# <b>1 array</b>
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 340px; position: absolute"><code>getlocal_WC_0  v@0
newarray       1
getlocal_WC_0  v@0
concattoarray
getlocal_WC_0  v@0
pushtoarray    1
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/119">
<div class="notes">I think it is good that I was able to reuse VM instructions that I added to speed up method calls to also speed up literal arrays.  However, I ran into a case that was not possible to optimize with existing instructions.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 420px; left: 514px;">Literal</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 563px; left: 514px;">Arrays</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/120">
<div class="notes">This case involved using keyword splats in literal arrays.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 420px; left: 514px;">Literal</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 563px; left: 514px;">Arrays</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 710px; left: 534px;">with Keyword</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 863px; left: 514px;">Splats</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/121">
<div class="notes">Here is the example.  We create a literal array using a splat of an array, and a keyword splat of a hash.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/122">
<div class="notes">Ruby 3.3 allocates three arrays for this case.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# <b>3 arrays</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/123">
<div class="notes">It uses the following simplified VM instructions for creating the literal array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
newarraykwsplat   1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/124">
<div class="notes">This set of instructions is for the keyword splat.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
<b class="block">putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2</b>
newarraykwsplat   1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/125">
<div class="notes">These 3 instructions each allocate an array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
<b>splatarray        true</b>
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
<b class="block">newarraykwsplat   1
concatarray</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/126">
<div class="notes">This array allocation is needed, since a literal array does need to allocate an array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
<b>splatarray        true</b>
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
newarraykwsplat   1
concatarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/127">
<div class="notes">But the array allocations for these instructions should be eliminated.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
<b class="block">newarraykwsplat   1
concatarray</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/128">
<div class="notes">It is possible to save one array allocation by changing this concatarray instruction</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
newarraykwsplat   1
<b>concatarray</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/129">
<div class="notes">to concattoarray, which does not allocate a new array</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
newarraykwsplat   1
<b>concattoarray</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/130">
<div class="notes">However, then we would not be able to eliminate the array allocation in the newarraykwsplat instruction, since concattoarray can only combine arrays.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
<b>newarraykwsplat   1</b>
concattoarray
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/131">
<div class="notes">Unfortunately, it is not possible to replace both instructions with a pushtoarray instruction, because this will push an empty hash onto the array if the keyword splat is empty.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
<b>pushtoarray       1</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/132">
<div class="notes">The simplest solution to avoid the unnecessary array allocation was to add a new VM instruction with the expected semantics, so that is what I did.  This instruction is named pushtoarraykwsplat, and it is similar to pushtoarray, but it does not accept an argument. This instruction pops the VM stack, then appends the popped object to the array at the current top of the VM stack, unless the popped object is an empty hash.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# 3 arrays
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
<b>pushtoarraykwsplat</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/133">
<div class="notes">With that change, literal arrays with keyword splats only allocate a single array in Ruby 3.4.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {kw: 1}
[*v, **h]
# <b>1 array</b>
</code></pre>

<pre style="font-size: 64px; margin-top: 28px; margin-left: 30px; left: 0; top: 290px; position: absolute"><code>
getlocal_WC_0     v@0
splatarray        true
putspecialobject  1
newhash           0
getlocal_WC_0     h@1
send              #hash_merge_kwd, argc:2
pushtoarraykwsplat
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/134">
<div class="notes">Related to this, before I started work on this optimization, we received a bug report that Ruby's behavior for this case was actually incorrect.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {}
[*v, **h]
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/135">
<div class="notes">If you were keyword splatting an empty hash,</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
<b>h = {}</b>
[*v, **h]
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/136">
<div class="notes">and the keyword splat was directly after a positional splat, with no elements in between,</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {}
[<b>*v, **h</b>]
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/137">
<div class="notes">then Ruby 3.3 and below would include an empty hash in the array.|I submitted a pull request that fixed this bug in a backwards compatible way before working on the literal array optimizations. The pushtoarraykwsplat instruction optimization also fixed this bug, and was committed first.|However, my original pull request was backported to Ruby 3.2 and 3.3.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {}
[*v, **h]
# =&gt; <b>[{}]</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/138">
<div class="notes">So now Ruby 3.2 and above will no longer include an empty hash for an empty keyword splat in a literal array.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 28px; margin-left: 30px;"><code>v = []
h = {}
[*v, **h]
# =&gt; <b>[]</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/139">
<div class="notes">With those optimizations, I believe that all literal arrays now only allocate a single array in Ruby 3.4.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 420px; left: 514px;">Literal</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 563px; left: 514px;">Arrays</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/140">
<div class="notes">I am now going to discuss how I eliminated unnecessary caller-side positional splat allocations.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 320px; left: 314px;">Caller-Side</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 463px; left: 314px;">Splat</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 620px; left: 344px;">Allocations</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/141">
<div class="notes">In Ruby 3.3, I was able to eliminate implicit array allocations for the following method calls, by adding an optimization pass that changed splatarray true to splatarray false. Unfortunately, while the approach of using the optimizer worked for these types of calls,</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code># No Array Allocated
a(1, *ary)
a(1, *ary, &amp;block)
a(*ary, **kw)
a(*ary, **kw, &amp;block)
a(*ary, kw: 1)
a(*ary, kw: 1, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/142">
<div class="notes">it did not work for other types of calls.  These calls all allocated an unnecessary array for the positional splat.  All of these cases result in a dynamic hash after the positional splat, which is not one of the cases that the optimizer can optimize, because the instructions for creating dynamic hashes are not fixed.|Optimizing these cases requires knowledge of the parse tree, not just access to the unoptimized instructions.  This meant that to optimize these cases, I would have to move the optimization from the optimizer to the compiler.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code># No Array Allocated
a(1, *ary)
a(1, *ary, &amp;block)
a(*ary, **kw)
a(*ary, **kw, &amp;block)
a(*ary, kw: 1)
a(*ary, kw: 1, &amp;block)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code><b class="block"># Array Allocated
a(*ary, **kw, **kw)
a(*ary, **kw, **kw, &amp;block)
a(*ary, kw: 1, **kw)
a(*ary, kw: 1, **kw, &amp;block)
a(*ary, kw: lvar)
a(*ary, kw: lvar, &amp;block)
a(*ary, kw: @ivar)
a(*ary, kw: @ivar, &amp;block)
a(1, *ary, **kw, **kw)
a(1, *ary, **kw, **kw, &amp;block)
a(1, *ary, kw: 1, **kw)
a(1, *ary, kw: 1, **kw, &amp;block)</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/143">
<div class="notes">So it looked into how to optimize these cases in the compiler.  At the time, the default parser was parse.y, and the main function for compiling arguments for method calls when using parse.y is named setup_args_core.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static int
setup_args_core(rb_iseq_t *iseq, LINK_ANCHOR *const args, const NODE *argn,
                int dup_rest, unsigned int *flag_ptr,
                struct rb_callinfo_kwarg **kwarg_ptr)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/144">
<div class="notes">The fourth argument is whether you should duplicate an array being splatted.  This is what controls whether the method call allocates an array for the splat.|My first thought to optimize these cases was to look for places where we are passing non-zero for the dup_rest argument, and see it we can change it to pass zero while still complying with Ruby semantics.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static int
setup_args_core(rb_iseq_t *iseq, LINK_ANCHOR *const args, const NODE *argn,
                <b>int dup_rest</b>, unsigned int *flag_ptr,
                struct rb_callinfo_kwarg **kwarg_ptr)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/145">
<div class="notes">One case I found is this recursive call, inside setup_args_core.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT | VM_CALL_ARGS_SPLAT_MUT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, 1, NULL, NULL);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/146">
<div class="notes">This case happens when compiling an ARGSPUSH node.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case <b>NODE_ARGSPUSH</b>: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT | VM_CALL_ARGS_SPLAT_MUT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, 1, NULL, NULL);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/147">
<div class="notes">The ARGSPUSH node is used in Ruby when you have arguments following a positional splat. Here are examples of calls that would use an ARGSPUSH node.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT | VM_CALL_ARGS_SPLAT_MUT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, 1, NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/148">
<div class="notes">This type of method call, with a positional argument following a positional splat, needs to allocate an array, because Ruby's internal method calling API does not handle positional arguments after a positional splat, so an array needs to be allocated for the positional splat, and the argument following the splat needs to be appended to that array.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT | VM_CALL_ARGS_SPLAT_MUT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, 1, NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code><b>m(*ary, {kw: 1})</b>
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/149">
<div class="notes">These four calls do not need to allocate an array, because there is only a positional splat, and no positional arguments following the splat.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT | VM_CALL_ARGS_SPLAT_MUT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, 1, NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
<b class="block">m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/150">
<div class="notes">These two cases were previously optimized via the optimizer in Ruby 3.3.  So the compiler would create instructions that allocated an array, but the optimizer would recognize those instruction combinations, and change them so they did not allocate an array.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT | VM_CALL_ARGS_SPLAT_MUT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, 1, NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
<b class="block">m(*ary, kw: 1)
m(*ary, **kw)</b>
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/151">
<div class="notes">These are two cases that allocated an unnecessary array in Ruby 3.3, because the optimizer only handled cases where static keywords or a single keyword splat were used.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT | VM_CALL_ARGS_SPLAT_MUT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, 1, NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
<b class="block">m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/152">
<div class="notes">Here we are calling setup_args_core with a non-zero value, forcing array allocations for splats in this recursive call, even though array allocations may not always be necessary. It turns out, in some cases, we can know before the recursive call that it is safe to avoid the array allocation.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT | VM_CALL_ARGS_SPLAT_MUT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, <b>1</b>, NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/153">
<div class="notes">By replacing those two lines with this code, I was able to optimize more cases. Let me go over what this new code does.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
<b class="block">        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);</b>
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/154">
<div class="notes">First, realize that this code is the same as the previous code, just split into an additional if statement.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
<b class="block">        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;</b>

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }
<b class="block">        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }</b>
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/155">
<div class="notes">This is the new code being added.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

<b class="block">        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }</b>
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/156">
<div class="notes">The first condition for the optimization is the head of the ARGSPUSH node is a SPLAT node.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (<b>nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT</b>) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/157">
<div class="notes">That is true in all of these cases, since the first argument to the method is a positional splat.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (<b>nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT</b>) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(<b>*ary</b>, {kw: 1})
m(<b>*ary</b>, kw: 1)
m(<b>*ary</b>, **kw)
m(<b>*ary</b>, kw: 1, **kw)
m(<b>*ary</b>, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/158">
<div class="notes">The second condition is the body of the ARGSPUSH node is a HASH node.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(<b>RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH</b>) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 628px; margin-left: 30px;"><code>m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/159">
<div class="notes">That is true for all of these cases, because literal hashes, literal keywords, and keyword splats are all parsed as HASH nodes.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                <b>nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH</b>) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, <b>{kw: 1}</b>)
m(*ary, <b>kw: 1</b>)
m(*ary, <b>**kw</b>)
m(*ary, <b>kw: 1, **kw</b>)
m(*ary, <b>**kw, **kw</b>)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/160">
<div class="notes">The final condition is that nd_brace is not set.  nd_brace is set on HASH nodes for literal hashes, but not set on HASH nodes for literal keywords or keyword splats.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                <b>!RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace</b>) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/161">
<div class="notes">This affects the bottom four cases, which all use literal keywords and/or keyword splats and do not need to allocate an array, but not the top case, which uses a literal hash, and does need to allocate.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                <b>!RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace</b>) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, <b>kw: 1</b>)
m(*ary, <b>**kw</b>)
m(*ary, <b>kw: 1, **kw</b>)
m(*ary, <b>**kw, **kw</b>)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/162">
<div class="notes">If all three of those conditions are true,</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

<b class="block">        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {</b>
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/163">
<div class="notes">then the recursive call to setup_args_core is set to not allocate an array for the splat.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            <b>recurse_dup_rest = 0;</b>
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, <b>recurse_dup_rest</b>,
                                   NULL, NULL);
</code></pre>

<pre class="sh_ruby" style="font-size: 64px; position: absolute; bottom: 30px; left: 30px;"><code>m(*ary, {kw: 1})
m(*ary, kw: 1)
m(*ary, **kw)
m(*ary, kw: 1, **kw)
m(*ary, **kw, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/164">
<div class="notes">That eliminated the array allocation for these calls.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code># No Array Allocated
a(1, *ary)
a(1, *ary, &amp;block)
a(*ary, **kw)
a(*ary, **kw, &amp;block)
a(*ary, kw: 1)
a(*ary, kw: 1, &amp;block)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code><b class="block"># No Array Allocated
a(*ary, **kw, **kw)
a(*ary, **kw, **kw, &amp;block)
a(*ary, kw: 1, **kw)
a(*ary, kw: 1, **kw, &amp;block)
a(*ary, kw: lvar)
a(*ary, kw: lvar, &amp;block)
a(*ary, kw: @ivar)
a(*ary, kw: @ivar, &amp;block)</b>

# Array Allocated
a(1, *ary, **kw, **kw)
a(1, *ary, **kw, **kw, &amp;block)
a(1, *ary, kw: 1, **kw)
a(1, *ary, kw: 1, **kw, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/165">
<div class="notes">However, Ruby would still allocate an array for these calls.  That is because these calls use a different parse tree.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code># No Array Allocated
a(1, *ary)
a(1, *ary, &amp;block)
a(*ary, **kw)
a(*ary, **kw, &amp;block)
a(*ary, kw: 1)
a(*ary, kw: 1, &amp;block)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code># No Array Allocated
a(*ary, **kw, **kw)
a(*ary, **kw, **kw, &amp;block)
a(*ary, kw: 1, **kw)
a(*ary, kw: 1, **kw, &amp;block)
a(*ary, kw: lvar)
a(*ary, kw: lvar, &amp;block)
a(*ary, kw: @ivar)
a(*ary, kw: @ivar, &amp;block)

<b class="block"># Array Allocated
a(1, *ary, **kw, **kw)
a(1, *ary, **kw, **kw, &amp;block)
a(1, *ary, kw: 1, **kw)
a(1, *ary, kw: 1, **kw, &amp;block)</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/166">
<div class="notes">I will choose these two calls to show the difference. The only difference between these two calls is the bottom call has an argument before the positional splat.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code># No Array Allocated
a(1, *ary)
a(1, *ary, &amp;block)
a(*ary, **kw)
a(*ary, **kw, &amp;block)
a(*ary, kw: 1)
a(*ary, kw: 1, &amp;block)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code># No Array Allocated
<b>a(*ary, **kw, **kw)</b>
a(*ary, **kw, **kw, &amp;block)
a(*ary, kw: 1, **kw)
a(*ary, kw: 1, **kw, &amp;block)
a(*ary, kw: lvar)
a(*ary, kw: lvar, &amp;block)
a(*ary, kw: @ivar)
a(*ary, kw: @ivar, &amp;block)

# Array Allocated
<b>a(1, *ary, **kw, **kw)</b>
a(1, *ary, **kw, **kw, &amp;block)
a(1, *ary, kw: 1, **kw)
a(1, *ary, kw: 1, **kw, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/167">
<div class="notes">Here is the simplified parse tree for both calls</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_SPLAT
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code>a(1, *ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_ARGSCAT
#    NODE_LIST
#     NODE_LIT: 1
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/168">
<div class="notes">This is the difference between the parse trees.  Without a leading argument, a SPLAT node is used, but with a leading argument, an ARGSCAT node is used.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
<b class="block">#   NODE_SPLAT
#    NODE_LVAR</b>
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code>a(1, *ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
<b class="block">#   NODE_ARGSCAT
#    NODE_LIST
#     NODE_LIT: 1
#    NODE_LVAR</b>
#  NODE_HASH (keyword argument)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/169">
<div class="notes">ARGSCAT node compilation had similar code to ARGSPUSH node compilation, in that it told recursive calls to allocate a new array. However, the same optimization could not be safely applied to the ARGSCAT node.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_SPLAT
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code>a(1, *ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   <b>NODE_ARGSCAT</b>
#    NODE_LIST
#     NODE_LIT: 1
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/170">
<div class="notes">That is because ARGSCAT is also used for method calls with multiple positional splats.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_SPLAT
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code>a(1, *ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_ARGSCAT
#    NODE_LIST
#     NODE_LIT: 1
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; position: absolute; top: 440px; left: 20px;"><code><b class="block">a(1, *ary, *ary)
# NODE_FCALL
#  NODE_ARGSCAT
#   NODE_ARGSCAT
#    NODE_LIST
#     NODE_LIT: 1
#     NODE_LVAR
#  NODE_LVAR</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/171">
<div class="notes">To properly optimize, you would need to compile these two ARGSCAT nodes differently.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_SPLAT
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code>a(1, *ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   <b>NODE_ARGSCAT</b>
#    NODE_LIST
#     NODE_LIT: 1
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; position: absolute; top: 440px; left: 20px;"><code>a(1, *ary, *ary)
# NODE_FCALL
#  NODE_ARGSCAT
#   <b>NODE_ARGSCAT</b>
#    NODE_LIST
#     NODE_LIT: 1
#     NODE_LVAR
#  NODE_LVAR
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/172">
<div class="notes">You would want this ARGSCAT node to not allocate an array, because only a single positional splat is used.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_SPLAT
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code>a(1, *ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   <b>NODE_ARGSCAT</b>
#    NODE_LIST
#     NODE_LIT: 1
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; position: absolute; top: 440px; left: 20px;"><code>a(1, *ary, *ary)
# NODE_FCALL
#  NODE_ARGSCAT
#   NODE_ARGSCAT
#    NODE_LIST
#     NODE_LIT: 1
#     NODE_LVAR
#  NODE_LVAR
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/173">
<div class="notes">You would want this ARGSCAT node to allocate an array, since there are multiple positional splats. I could not see how that was possible with the setup_args_core API.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_SPLAT
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code>a(1, *ary, **kw, **kw)
# NODE_FCALL
#  NODE_ARGSPUSH
#   NODE_ARGSCAT
#    NODE_LIST
#     NODE_LIT: 1
#    NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; position: absolute; top: 440px; left: 20px;"><code>a(1, *ary, *ary)
# NODE_FCALL
#  NODE_ARGSCAT
#   <b>NODE_ARGSCAT</b>
#    NODE_LIST
#     NODE_LIT: 1
#     NODE_LVAR
#  NODE_LVAR
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/174">
<div class="notes">So I changed the API.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static int
setup_args_core(rb_iseq_t *iseq, LINK_ANCHOR *const args, const NODE *argn,
                int dup_rest, unsigned int *flag_ptr,
                struct rb_callinfo_kwarg **kwarg_ptr)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/175">
<div class="notes">Instead of taking an integer for whether the current node you are compiling should allocate an array for a splat.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static int
setup_args_core(rb_iseq_t *iseq, LINK_ANCHOR *const args, const NODE *argn,
                <b>int</b> dup_rest, unsigned int *flag_ptr,
                struct rb_callinfo_kwarg **kwarg_ptr)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/176">
<div class="notes">I changed the argument to be a pointer to unsigned int.  This allowed for tracking this information in a single place across recursive calls to setup_args_core.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static int
setup_args_core(rb_iseq_t *iseq, LINK_ANCHOR *const args, const NODE *argn,
                <b>unsigned int*</b> dup_rest, unsigned int *flag_ptr,
                struct rb_callinfo_kwarg **kwarg_ptr)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/177">
<div class="notes">For the ARGSPUSH node compilation, which I previously changed to this.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int recurse_dup_rest = 1;

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/178">
<div class="notes">I was able to take all this code,</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
<b class="block">        int recurse_dup_rest = 1;

        if (nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_head, NODE_SPLAT) &amp;&amp;
                nd_type_p(RNODE_ARGSPUSH(argn)-&gt;nd_body, NODE_HASH) &amp;&amp;
                !RNODE_HASH(RNODE_ARGSPUSH(argn)-&gt;nd_body)-&gt;nd_brace) {
            recurse_dup_rest = 0;
        }
        else if (flag_ptr) {
            *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }</b>
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/179">
<div class="notes">and delete it.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, recurse_dup_rest,
                                   NULL, NULL);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/180">
<div class="notes">As I was no longer defining this variable,</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, <b>recurse_dup_rest</b>,
                                   NULL, NULL);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/181">
<div class="notes">I just had it pass the existing pointer directly.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_ARGSPUSH: {
        if (flag_ptr) *flag_ptr |= VM_CALL_ARGS_SPLAT;
        int argc = setup_args_core(iseq, args, RNODE_ARGSPUSH(argn)-&gt;nd_head, <b>dup_rest</b>,
                                   NULL, NULL);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/182">
<div class="notes">Here is a case where the dup_rest argument was used to make a decision about whether to allocate an array for the splat.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_SPLAT: {
        // f(*a)
        NO_CHECK(COMPILE(args, "args (splat)", RNODE_SPLAT(argn)-&gt;nd_head));
        ADD_INSN1(args, argn, splatarray, RBOOL(dup_rest));
        if (flag_ptr)  {
            *flag_ptr |= VM_CALL_ARGS_SPLAT;
            if (dup_rest) *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/183">
<div class="notes">This adds the splatarray instruction,</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_SPLAT: {
        // f(*a)
        NO_CHECK(COMPILE(args, "args (splat)", RNODE_SPLAT(argn)-&gt;nd_head));
        ADD_INSN1(args, argn, <b>splatarray</b>, RBOOL(dup_rest));
        if (flag_ptr)  {
            *flag_ptr |= VM_CALL_ARGS_SPLAT;
            if (dup_rest) *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/184">
<div class="notes">and the argument to the splatarray instruction is whether to allocate an array for the splat.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_SPLAT: {
        // f(*a)
        NO_CHECK(COMPILE(args, "args (splat)", RNODE_SPLAT(argn)-&gt;nd_head));
        ADD_INSN1(args, argn, splatarray, <b>RBOOL(dup_rest)</b>);
        if (flag_ptr)  {
            *flag_ptr |= VM_CALL_ARGS_SPLAT;
            if (dup_rest) *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/185">
<div class="notes">Now that dup_rest is a pointer and not an integer, we need to change this to dereference the pointer.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_SPLAT: {
        // f(*a)
        NO_CHECK(COMPILE(args, "args (splat)", RNODE_SPLAT(argn)-&gt;nd_head));
        ADD_INSN1(args, argn, splatarray, RBOOL(<b>*</b>dup_rest));
        if (flag_ptr)  {
            *flag_ptr |= VM_CALL_ARGS_SPLAT;
            if (dup_rest) *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;
        }
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/186">
<div class="notes">This code previously set that the positional splat was mutable if we were allocating a new array.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_SPLAT: {
        // f(*a)
        NO_CHECK(COMPILE(args, "args (splat)", RNODE_SPLAT(argn)-&gt;nd_head));
        ADD_INSN1(args, argn, splatarray, RBOOL(*dup_rest));
        if (flag_ptr)  {
            *flag_ptr |= VM_CALL_ARGS_SPLAT;
            <b>if (dup_rest) *flag_ptr |= VM_CALL_ARGS_SPLAT_MUT;</b>
        }
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/187">
<div class="notes">That code was eliminated from this branch and other similar branches, and moved to a centralized location.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_SPLAT: {
        // f(*a)
        NO_CHECK(COMPILE(args, "args (splat)", RNODE_SPLAT(argn)-&gt;nd_head));
        ADD_INSN1(args, argn, splatarray, RBOOL(*dup_rest));
        if (flag_ptr)  {
            *flag_ptr |= VM_CALL_ARGS_SPLAT;
        }
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/188">
<div class="notes">To ensure we never allocate more than one array per method call, if we did allocate an array in the splatarray argument, we set the dup_rest flag to zero, so no more arrays will be allocated.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>      case NODE_SPLAT: {
        // f(*a)
        NO_CHECK(COMPILE(args, "args (splat)", RNODE_SPLAT(argn)-&gt;nd_head));
        ADD_INSN1(args, argn, splatarray, RBOOL(*dup_rest));
        <b>if (*dup_rest) *dup_rest = 0;</b>
        if (flag_ptr)  {
            *flag_ptr |= VM_CALL_ARGS_SPLAT;
        }
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/189">
<div class="notes">To avoid unnecessary allocations, we decide whether to allocate an array for the positional splat before the call to setup_args_core.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>  unsigned int dup_rest = 1;
  
  if (should_not_allocate) {
    dup_rest = 0;
  }

  setup_args_core(iseq, args, argn, &amp;dup_rest, flag, keywords)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/190">
<div class="notes">We default to allocating an array.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>  unsigned int <b>dup_rest = 1</b>;
  
  if (should_not_allocate) {
    dup_rest = 0;
  }

  setup_args_core(iseq, args, argn, &amp;dup_rest, flag, keywords)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/191">
<div class="notes">If we are sure an array allocation is not needed,</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>  unsigned int dup_rest = 1;
  
  if (<b>should_not_allocate</b>) {
    dup_rest = 0;
  }

  setup_args_core(iseq, args, argn, &amp;dup_rest, flag, keywords)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/192">
<div class="notes">then we set the call to not allocate an array.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>  unsigned int dup_rest = 1;
  
  if (should_not_allocate) {
    <b>dup_rest = 0</b>;
  }

  setup_args_core(iseq, args, argn, &amp;dup_rest, flag, keywords)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/193">
<div class="notes">This is psuedocode, as it takes a significant amount of code to determine whether it is safe to avoid allocation.|There are four parse tree cases where we can avoid allocating an array.</div>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>  unsigned int dup_rest = 1;
  
  if (<b>should_not_allocate</b>) {
    dup_rest = 0;
  }

  setup_args_core(iseq, args, argn, &amp;dup_rest, flag, keywords)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/194">
<div class="notes">The first case is when the only argument is a positional splat.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/195">
<div class="notes">The primary argument node in this case is a SPLAT node.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary)
# NODE_SPLAT
#    NODE_LVAR
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/196">
<div class="notes">If the primary argument node is a SPLAT node, it is always safe to avoid allocation.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary)
# NODE_SPLAT
#    NODE_LVAR
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>case(<b>NODE_SPLAT</b>):
  // avoid caller side array allocation for f(*arg)
  dup_rest = 0;
  break;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/197">
<div class="notes">The second case is when there are one or more positional arguments followed by a positional splat.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(1, *ary)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/198">
<div class="notes">In this case, the primary argument node is an ARGSCAT node, and the head of the ARGSCAT node is a LIST node.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(1, *ary)
# NODE_ARGSCAT
#  NODE_LIST
#   NODE_LIT: 1
#  NODE_LVAR
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/199">
<div class="notes">So the code checks if the primary argument node is an ARGSCAT node,</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(1, *ary)
# NODE_ARGSCAT
#  NODE_LIST
#   NODE_LIT: 1
#  NODE_LVAR
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>
case(<b>NODE_ARGSCAT</b>):
  // avoid caller side array allocation for f(1, *arg)
  dup_rest = !nd_type_p(RNODE_ARGSCAT(check_arg)-&gt;nd_head, NODE_LIST);
  break;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/200">
<div class="notes">and if the head of the ARGSCAT node is a LIST node, then it is safe to avoid allocation.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(1, *ary)
# NODE_ARGSCAT
#  NODE_LIST
#   NODE_LIT: 1
#  NODE_LVAR
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>
case(NODE_ARGSCAT):
  // avoid caller side array allocation for f(1, *arg)
  dup_rest = <b>!nd_type_p(RNODE_ARGSCAT(check_arg)-&gt;nd_head, NODE_LIST)</b>;
  break;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/201">
<div class="notes">The third case is when there is a positional splat followed by literal keywords or a keyword splat.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/202">
<div class="notes">The parse tree for this case has ARGSPUSH as the primary argument node, with the head being a SPLAT node and the body being a HASH node that is a keyword argument.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/203">
<div class="notes">The third and fourth cases are related, so I will discuss the fourth case at the same time.  This is when there are one or more positional arguments, followed by a positional splat, and then followed by literal keywords or a keyword splat.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; left: 960px; top: 0; position: absolute;"><code>a(1, *ary, **kw)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/204">
<div class="notes">In the fourth case, instead of a SPLAT node, you have an ARGSCAT node where the head is a LIST node.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; left: 960px; top: 0; position: absolute;"><code>a(1, *ary, **kw)
# NODE_ARGSPUSH
#  NODE_ARGSCAT
#   NODE_LIST
#    NODE_LIT: 1
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/205">
<div class="notes">So the code first checks that the primary argument node is ARGSPUSH,</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; left: 960px; top: 0; position: absolute;"><code>a(1, *ary, **kw)
# NODE_ARGSPUSH
#  NODE_ARGSCAT
#   NODE_LIST
#    NODE_LIT: 1
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 148px; margin-left: 20px;"><code>case(<b>NODE_ARGSPUSH</b>):
  // avoid caller side array allocation for f(*arg, **hash) and f(1, *arg, **hash)
  dup_rest = !((nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_SPLAT) ||
  (nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_ARGSCAT) &amp;&amp;
  nd_type_p(RNODE_ARGSCAT(RNODE_ARGSPUSH(check_arg)-&gt;nd_head)-&gt;nd_head, NODE_LIST))) &amp;&amp;
  nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_body, NODE_HASH) &amp;&amp;
  !RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_brace);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/206">
<div class="notes">and if so, checks whether the head of that node is a SPLAT node</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; left: 960px; top: 0; position: absolute;"><code>a(1, *ary, **kw)
# NODE_ARGSPUSH
#  NODE_ARGSCAT
#   NODE_LIST
#    NODE_LIT: 1
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 148px; margin-left: 20px;"><code>case(NODE_ARGSPUSH):
  // avoid caller side array allocation for f(*arg, **hash) and f(1, *arg, **hash)
  dup_rest = !((nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, <b>NODE_SPLAT</b>) ||
  (nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_ARGSCAT) &amp;&amp;
  nd_type_p(RNODE_ARGSCAT(RNODE_ARGSPUSH(check_arg)-&gt;nd_head)-&gt;nd_head, NODE_LIST))) &amp;&amp;
  nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_body, NODE_HASH) &amp;&amp;
  !RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_brace);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/207">
<div class="notes">or the head is an ARGSCAT node where the head of that is a LIST node.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; left: 960px; top: 0; position: absolute;"><code>a(1, *ary, **kw)
# NODE_ARGSPUSH
#  NODE_ARGSCAT
#   NODE_LIST
#    NODE_LIT: 1
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 148px; margin-left: 20px;"><code>case(NODE_ARGSPUSH):
  // avoid caller side array allocation for f(*arg, **hash) and f(1, *arg, **hash)
  dup_rest = !((nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_SPLAT) ||
  (nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, <b>NODE_ARGSCAT</b>) &amp;&amp;
  nd_type_p(RNODE_ARGSCAT(RNODE_ARGSPUSH(check_arg)-&gt;nd_head)-&gt;nd_head, <b>NODE_LIST</b>))) &amp;&amp;
  nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_body, NODE_HASH) &amp;&amp;
  !RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_brace);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/208">
<div class="notes">Finally, the code checks whether the body of the ARGSPUSH node is a HASH node where nd_brace is not set.|With these four cases handled, I was able to avoid array allocation for all cases where a single positional splat and no post-splat positional arguments are used.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; left: 960px; top: 0; position: absolute;"><code>a(1, *ary, **kw)
# NODE_ARGSPUSH
#  NODE_ARGSCAT
#   NODE_LIST
#    NODE_LIT: 1
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 148px; margin-left: 20px;"><code>case(NODE_ARGSPUSH):
  // avoid caller side array allocation for f(*arg, **hash) and f(1, *arg, **hash)
  dup_rest = !((nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_SPLAT) ||
  (nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_ARGSCAT) &amp;&amp;
  nd_type_p(RNODE_ARGSCAT(RNODE_ARGSPUSH(check_arg)-&gt;nd_head)-&gt;nd_head, NODE_LIST))) &amp;&amp;
  nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_body, <b>NODE_HASH</b>) &amp;&amp;
  <b>!</b>RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;<b>nd_brace</b>);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/209">
<div class="notes">Unfortunately, this broke tests, because it is actually not safe to eliminate the allocation for all such calls.  For example, if kw is a local variable, it is safe to avoid allocation, but if kw is a method call, then it is not safe, because the method call could modify the array being splatted, and that is an evaluation order issue.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **<b>kw</b>)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; left: 960px; top: 0; position: absolute;"><code>a(1, *ary, **<b>kw</b>)
# NODE_ARGSPUSH
#  NODE_ARGSCAT
#   NODE_LIST
#    NODE_LIT: 1
#   NODE_LVAR
#  NODE_HASH (keyword argument)
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 148px; margin-left: 20px;"><code>case(NODE_ARGSPUSH):
  // avoid caller side array allocation for f(*arg, **hash) and f(1, *arg, **hash)
  dup_rest = !((nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_SPLAT) ||
  (nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_ARGSCAT) &amp;&amp;
  nd_type_p(RNODE_ARGSCAT(RNODE_ARGSPUSH(check_arg)-&gt;nd_head)-&gt;nd_head, NODE_LIST))) &amp;&amp;
  nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_body, NODE_HASH) &amp;&amp;
  !RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_brace);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/210">
<div class="notes">In order to be safe, you need to inspect all subnodes of the HASH node, and determine whether any of those nodes contains an expression that could cause an evaluation order issue.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>a(*ary, **kw)
# NODE_ARGSPUSH
#  NODE_SPLAT
#   NODE_LVAR
#  <b>NODE_HASH (keyword argument)</b>
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; left: 960px; top: 0; position: absolute;"><code>a(1, *ary, **kw)
# NODE_ARGSPUSH
#  NODE_ARGSCAT
#   NODE_LIST
#    NODE_LIT: 1
#   NODE_LVAR
#  <b>NODE_HASH (keyword argument)</b>
</code></pre>

<pre class="sh_c" style="font-size: 32px; margin-top: 148px; margin-left: 20px;"><code>case(NODE_ARGSPUSH):
  // avoid caller side array allocation for f(*arg, **hash) and f(1, *arg, **hash)
  dup_rest = !((nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_SPLAT) ||
  (nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_head, NODE_ARGSCAT) &amp;&amp;
  nd_type_p(RNODE_ARGSCAT(RNODE_ARGSPUSH(check_arg)-&gt;nd_head)-&gt;nd_head, NODE_LIST))) &amp;&amp;
  nd_type_p(RNODE_ARGSPUSH(check_arg)-&gt;nd_body, NODE_HASH) &amp;&amp;
  !RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_brace);
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/211">
<div class="notes">So I added a function that can be passed a node and will return true if the node could potentially modify an existing argument splat.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/212">
<div class="notes">This will allow local and instance variables,</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case <b>NODE_LVAR</b>:
      case NODE_DVAR:
      case NODE_GVAR:
      case <b>NODE_IVAR</b>:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/213">
<div class="notes">most literals,</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
<b class="block">      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:</b>
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/214">
<div class="notes">as well as most constant references</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case <b>NODE_CONST</b>:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case <b>NODE_COLON2</b>:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/215">
<div class="notes">This line handles nested constants, which may not be safe.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return <b>setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head)</b>;
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/216">
<div class="notes">For example, this type of nested constant reference, where all parts are constant references, is safe enough to not force allocating an array for the splat.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      default:
        return true;
    }
}
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; top: 340px; left: 660px; position: absolute;"><code><b>Foo::Bar # safe</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/217">
<div class="notes">However, this type of constant reference, which looks for a constant under a module returned by a method call, is not safe, as the method call could modify the argument being splatted.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      default:
        return true;
    }
}
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; top: 340px; left: 660px; position: absolute;"><code>Foo::Bar # safe
<b>method_call::Bar # not safe</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/218">
<div class="notes">With that function defined, the remaining step is to check all of the key and value nodes for literal keywords, as well as the nodes for keyword splats, so I added this code.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  while (node) {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/219">
<div class="notes">We start with the HASH node for the literal keywords and keyword splats.  All keys and values of literal keywords as well as keyword splats will be inside this node.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  <b>NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;</b>

  while (node) {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/220">
<div class="notes">Each entry inside this HASH node is either a key/value pair, or a keyword splat, and we will iterate over all of them.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  <b>while (node)</b> {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/221">
<div class="notes">The head of this node is the key node for a literal keyword, and NULL for a keyword splat.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  while (node) {
    <b>NODE *key_node = RNODE_LIST(node)-&gt;nd_head;</b>
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/222">
<div class="notes">If the key node is set, we call the function to determine whether the node is safe.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  while (node) {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (<b>key_node &amp;&amp; setup_args_dup_rest_p(key_node)</b>) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/223">
<div class="notes">If it is not safe, we mark that we need to allocate an array for the splat, and stop processing.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  while (node) {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      <b>dup_rest = 1;</b>
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/224">
<div class="notes">If it is safe, we move to the next node,</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  while (node) {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      dup_rest = 1;
      break;
    }

    <b>node = RNODE_LIST(node)-&gt;nd_next;</b>
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/225">
<div class="notes">and then get the head node for that, which is either the value node for a literal keyword, or the node for the keyword splat expression.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  while (node) {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    <b>NODE *value_node = RNODE_LIST(node)-&gt;nd_head;</b>
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/226">
<div class="notes">We do the same check as we did for the key node, and handle unsafe nodes the same way.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  while (node) {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
<b class="block">    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }</b>

    node = RNODE_LIST(node)-&gt;nd_next;
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/227">
<div class="notes">We repeat this process for every keyword or keyword splat in the method call.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest) {
  // require allocation for keyword key/value/splat that may modify splatted argument
  NODE *node = RNODE_HASH(RNODE_ARGSPUSH(check_arg)-&gt;nd_body)-&gt;nd_head;

  while (node) {
    NODE *key_node = RNODE_LIST(node)-&gt;nd_head;
    if (key_node &amp;&amp; setup_args_dup_rest_p(key_node)) {
      dup_rest = 1;
      break;
    }

    node = RNODE_LIST(node)-&gt;nd_next;
    NODE *value_node = RNODE_LIST(node)-&gt;nd_head;
    if (setup_args_dup_rest_p(value_node)) {
      dup_rest = 1;
      break;
    }

    <b>node = RNODE_LIST(node)-&gt;nd_next;</b>
  }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/228">
<div class="notes">It turns out that in addition to checking the keyword arguments, if a block is being passed via an ampersand, we also need to check the block pass expression.  Here is the code for that.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = 1;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/229">
<div class="notes">First, if we already know we are going to duplicate the array anyway, we do not need check the block pass expression.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (<b>!dup_rest</b> &amp;&amp; (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = 1;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/230">
<div class="notes">We only want to do this check if a block pass expression is provided.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; <b>(check_arg != argn)</b> &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = 1;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/231">
<div class="notes">We do the same check on the block pass expression that we did on the keywords.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; (check_arg != argn) &amp;&amp;
        <b>setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)</b>) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = 1;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/232">
<div class="notes">If the block pass expression is not safe, they we must duplicate the array being splatted.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    <b>dup_rest = 1;</b>
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/233">
<div class="notes">With that change, all cases that unnecessarily allocated a caller side array for a positional splat in Ruby 3.3 no longer do so in Ruby 3.4.| Additionally, I was able to remove the entire optimizer change I added in Ruby 3.3, because this compiler change handled all cases the optimizer handled, as well as all of these additional cases.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code># No Array Allocated
a(1, *ary)
a(1, *ary, &amp;block)
a(*ary, **kw)
a(*ary, **kw, &amp;block)
a(*ary, kw: 1)
a(*ary, kw: 1, &amp;block)
</code></pre>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 0; position: absolute; top: 0; left: 960px;"><code># No Array Allocated
<b>a(*ary, **kw, **kw)
a(*ary, **kw, **kw, &amp;block)
a(*ary, kw: 1, **kw)
a(*ary, kw: 1, **kw, &amp;block)
a(*ary, kw: lvar)
a(*ary, kw: lvar, &amp;block)
a(*ary, kw: @ivar)
a(*ary, kw: @ivar, &amp;block)
a(1, *ary, **kw, **kw)
a(1, *ary, **kw, **kw, &amp;block)
a(1, *ary, kw: 1, **kw)
a(1, *ary, kw: 1, **kw, &amp;block)</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/234">
<div class="notes">A while after making that optimization, I found a related evaluation order issue, in this type of method call.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(**h, &amp;h.delete(key))
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/235">
<div class="notes">Here we are keyword splatting a variable.  Since this is a single keyword splat without literal keywords, it would generally not be duplicated.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(<b>**h</b>, &amp;h.delete(key))
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/236">
<div class="notes">However, in the same method call, we are mutating the variable in the block pass expression.  If we don't duplicate the keyword splat expression, then this is an evaluation order issue, because the deleted key will not appear as a keyword argument.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(**h, <b>&amp;h.delete(key)</b>)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/237">
<div class="notes">To fix this evaluation order issue, we go back to the setup_args code.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = 1;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/238">
<div class="notes">We previously were only using 0 or 1 values for dup_rest.  However, we now want dup_rest to track two types of information.  The first type of information is whether the positional splat array should be duplicated.  The second type of information is whether keyword splat hash for a single keyword splat should be duplicated.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    <b>dup_rest = 1;</b>
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/239">
<div class="notes">In order to do that, I created macros for these two conditions.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = <b>SPLATARRAY_TRUE | DUP_SINGLE_KW_SPLAT</b>;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/240">
<div class="notes">SPLATARRAY_TRUE is used for the condition where we need to duplicate the splat array.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = <b>SPLATARRAY_TRUE</b> | DUP_SINGLE_KW_SPLAT;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/241">
<div class="notes">DUP_SINGLE_KW_SPLAT is used for the condition where we need to duplicate the keyword splat hash.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (!dup_rest &amp;&amp; (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = SPLATARRAY_TRUE | <b>DUP_SINGLE_KW_SPLAT</b>;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/242">
<div class="notes">Note that we want to set DUP_SINGLE_KW_SPLAT even if we are already going to be duplicating the splat array.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if (<b>!dup_rest &amp;&amp;</b> (check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = SPLATARRAY_TRUE | DUP_SINGLE_KW_SPLAT;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/243">
<div class="notes">So we need to remove this condition.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
if ((check_arg != argn) &amp;&amp;
        setup_args_dup_rest_p(RNODE_BLOCK_PASS(argn)-&gt;nd_body)) {
    // require allocation for block pass that may modify splatted argument
    dup_rest = SPLATARRAY_TRUE | DUP_SINGLE_KW_SPLAT;
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/244">
<div class="notes">Now that we have set that flag, we need to change the keyword compilation code to use it.  This is what the code looked like before the change.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
             if (!keyword_node_single_splat_p(kwnode)) {
                 *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
             }
             compile_hash(iseq, args, kwnode, TRUE, FALSE);
             argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/245">
<div class="notes">If the keyword splat node was not a single keyword splat,</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
             if (<b>!keyword_node_single_splat_p(kwnode)</b>) {
                 *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
             }
             compile_hash(iseq, args, kwnode, TRUE, FALSE);
             argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/246">
<div class="notes">We mark the method call as containing a mutable keyword.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
             if (!keyword_node_single_splat_p(kwnode)) {
                 <b>*flag_ptr |= VM_CALL_KW_SPLAT_MUT;</b>
             }
             compile_hash(iseq, args, kwnode, TRUE, FALSE);
             argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/247">
<div class="notes">Then we call compile_hash with the keyword node, which may be literal keywords and/or one or more keyword splats.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
             if (!keyword_node_single_splat_p(kwnode)) {
                 *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
             }
             <b>compile_hash(iseq, args, kwnode, TRUE, FALSE);</b>
             argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/248">
<div class="notes">Here is the code I added to fix the evaluation order issue.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
            if (!keyword_node_single_splat_p(kwnode)) {
                *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
<b class="block">                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }
            else if (*dup_rest &amp; DUP_SINGLE_KW_SPLAT) {
                compile_single_keyword_splat_mutable(iseq, args, argn,
                    kwnode, flag_ptr);
            }
            else {</b>
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }
            argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/249">
<div class="notes">These sections are basically the same as the previous code, split into two parts.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
<b class="block">            if (!keyword_node_single_splat_p(kwnode)) {
                *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }</b>
            else if (*dup_rest &amp; DUP_SINGLE_KW_SPLAT) {
                compile_single_keyword_splat_mutable(iseq, args, argn,
                    kwnode, flag_ptr);
            }
<b class="block">            else {
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }</b>
            argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/250">
<div class="notes">This is the new code.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
            if (!keyword_node_single_splat_p(kwnode)) {
                *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }
<b class="block">            else if (*dup_rest &amp; DUP_SINGLE_KW_SPLAT) {
                compile_single_keyword_splat_mutable(iseq, args, argn,
                    kwnode, flag_ptr);
            }</b>
            else {
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }
            argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/251">
<div class="notes">If the keyword node is a single keyword splat, and the DUP_SINGLE_KW_SPLAT flag is set.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
            if (!keyword_node_single_splat_p(kwnode)) {
                *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }
            else if (<b>*dup_rest &amp; DUP_SINGLE_KW_SPLAT</b>) {
                compile_single_keyword_splat_mutable(iseq, args, argn,
                    kwnode, flag_ptr);
            }
            else {
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }
            argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/252">
<div class="notes">We call a new function, designed only to compile single keyword splats where we need to duplicate the splat hash to avoid the evaluation order issue.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
            if (!keyword_node_single_splat_p(kwnode)) {
                *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }
            else if (*dup_rest &amp; DUP_SINGLE_KW_SPLAT) {
<b class="block">                compile_single_keyword_splat_mutable(iseq, args, argn,
                    kwnode, flag_ptr);</b>
            }
            else {
                compile_hash(iseq, args, kwnode, TRUE, FALSE);
            }
            argc += 1;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/253">
<div class="notes">Here is the definition of that function.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
static void
compile_single_keyword_splat_mutable(rb_iseq_t *iseq, LINK_ANCHOR *const args,
                                     const NODE *argn, NODE *kwnode,
                                     unsigned int *flag_ptr)
{
    *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
    ADD_INSN1(args, argn, putspecialobject, INT2FIX(VM_SPECIAL_OBJECT_VMCORE));
    ADD_INSN1(args, argn, newhash, INT2FIX(0));
    compile_hash(iseq, args, kwnode, TRUE, FALSE);
    ADD_SEND(args, argn, id_core_hash_merge_kwd, INT2FIX(2));
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/254">
<div class="notes">First, since we will be allocating a new hash for the keyword splat, we mark the method as passing a mutable keyword splat.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
static void
compile_single_keyword_splat_mutable(rb_iseq_t *iseq, LINK_ANCHOR *const args,
                                     const NODE *argn, NODE *kwnode,
                                     unsigned int *flag_ptr)
{
    <b>*flag_ptr |= VM_CALL_KW_SPLAT_MUT;</b>
    ADD_INSN1(args, argn, putspecialobject, INT2FIX(VM_SPECIAL_OBJECT_VMCORE));
    ADD_INSN1(args, argn, newhash, INT2FIX(0));
    compile_hash(iseq, args, kwnode, TRUE, FALSE);
    ADD_SEND(args, argn, id_core_hash_merge_kwd, INT2FIX(2));
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/255">
<div class="notes">This is the same compile_hash call that we had previously.  This will compile the keyword splat node without duplicating it.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
static void
compile_single_keyword_splat_mutable(rb_iseq_t *iseq, LINK_ANCHOR *const args,
                                     const NODE *argn, NODE *kwnode,
                                     unsigned int *flag_ptr)
{
    *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
    ADD_INSN1(args, argn, putspecialobject, INT2FIX(VM_SPECIAL_OBJECT_VMCORE));
    ADD_INSN1(args, argn, newhash, INT2FIX(0));
    <b>compile_hash(iseq, args, kwnode, TRUE, FALSE);</b>
    ADD_SEND(args, argn, id_core_hash_merge_kwd, INT2FIX(2));
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/256">
<div class="notes">These instructions create a new empty hash before the evaluating the keyword splat expression, and merge the keyword splat hash into the new hash.  In other words, this is duplicating the keyword splat hash.</div>

<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
static void
compile_single_keyword_splat_mutable(rb_iseq_t *iseq, LINK_ANCHOR *const args,
                                     const NODE *argn, NODE *kwnode,
                                     unsigned int *flag_ptr)
{
    *flag_ptr |= VM_CALL_KW_SPLAT_MUT;
<b class="block">    ADD_INSN1(args, argn, putspecialobject, INT2FIX(VM_SPECIAL_OBJECT_VMCORE));
    ADD_INSN1(args, argn, newhash, INT2FIX(0));</b>
    compile_hash(iseq, args, kwnode, TRUE, FALSE);
    <b>ADD_SEND(args, argn, id_core_hash_merge_kwd, INT2FIX(2));</b>
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/257">
<div class="notes">With that change, this code no longer had an evaluation order issue, as it now duplicates the keyword splat hash before calling delete on it.|One negative aspect of fixing this evaluation order issue is that it is pessimistic.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(**h, &amp;h.delete(key))
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/258">
<div class="notes">Let's say you have a method call like this,</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(**h, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/259">
<div class="notes">where the block argument is itself is a method call. In your class, it's a simple attr_reader method, so you know that it is safe to avoid allocation, as the block method will never modify the keyword splat hash.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(**h, &amp;<b>block</b>)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/260">
<div class="notes">Unfortunately, Ruby will always duplicate the keyword splat hash in this case.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(**<b>h</b>, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/261">
<div class="notes">That's because when compiling this method call, Ruby only knows that this is a method call, it doesn't know what type of method call or how the method is implemented.  Even if it did know that information, it wouldn't be safe to use instructions that avoided duplicating the keyword splat hash, because at any point, the method could be redefined to modify the keyword splat hash.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(**h, &amp;<b>block</b>)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/262">
<div class="notes">I thought it would be useful to issue a performance warning for this code, letting the user know that this code was implicitly allocating an unnecessary hash,</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
a(**h, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/263">
<div class="notes">and encouraging them to store the result of the method in a local variable. With that local variable set,</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code><b>block = self.block</b>
a(**h, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/264">
<div class="notes">block in the method call is a local variable reference and not a method call, so it cannot cause an evaluation order issue, and therefore the method call instructions do not need to duplicate the keyword splat hash, which saves a hash allocation.  I submitted a pull request and redmine ticket for this performance warning.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>block = self.block
a(**h, &amp;<b>block</b>)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/265">
<div class="notes">This performance warning found a method call with an unnecessary allocation in Sequel.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 314px;">Sequel: <span class="red">1</span>
</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/266">
<div class="notes">It found a method call with an unnecessary allocation in rubygems.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 314px;">rubygems: <span class="red">1</span>
</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/267">
<div class="notes">It found method calls with unnecessary allocations in a couple of standard libraries, pp and optparse.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 314px;">pp: <span class="red">1</span><br>
optparse: <span class="red">1</span>
</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/268">
<div class="notes">It found 5 method calls with unnecessary allocations in Rails.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 314px;">Rails: <span class="red">5</span>
</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/269">
<div class="notes">Unfortunately, Matz was not in favor of the idea. Admittedly, the performance warning was complex, and there a relatively few method call sites that were affected by it.</div>

<h1 class="blue" style="font-size: 220px; position: absolute; top: 320px; left: 214px;">
<span class="red">Not</span> Accepted</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/270">
<div class="notes">I mentioned that this found 5 method calls with unnecessary allocations in Rails. One of those turned out to be a case that probably should be optimized.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 314px;">Rails: <span class="red">5</span>
</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/271">
<div class="notes">Here's what that method call looks like.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
match(*path_or_actions, as:, to:, controller:, action:, on:,
      defaults:, constraints:, anchor:, format:, path:,
      internal:, **mapping, via: [:get, :connect], &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/272">
<div class="notes">In this method call, there is an array allocated for the positional splat.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
match(<b>*path_or_actions</b>, as:, to:, controller:, action:, on:,
      defaults:, constraints:, anchor:, format:, path:,
      internal:, **mapping, via: [:get, :connect], &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/273">
<div class="notes">The reason for this is that the via keyword argument uses a literal array.  Even though all elements of the literal array are themselves safe, the code I showed earlier to check whether arguments were safe did not include support for literal arrays.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
match(*path_or_actions, as:, to:, controller:, action:, on:,
      defaults:, constraints:, anchor:, format:, path:,
      internal:, **mapping, via: <b>[:get, :connect]</b>, &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/274">
<div class="notes">Let's take another look at that code. This supports a number of nodes,</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/275">
<div class="notes">but unfortunately, it doesn't support the node used for literal arrays, which is NODE_LIST.  So I decided to add support for that.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      <b>case NODE_LIST:</b>
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/276">
<div class="notes">Here's what that support looks like.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>
     case NODE_LIST:
        while (argn) {
            if (setup_args_dup_rest_p(RNODE_LIST(argn)-&amp;nd_head)) {
                return true;
            }
            argn = RNODE_LIST(argn)-&amp;nd_next;
        }
        return false;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/277">
<div class="notes">NODE_LIST is implemented as a linked list. Each NODE_LIST has a nd_head pointer to the node for the current element of the array, as well as a nd_next pointer to the NODE_LIST for the next element in the array.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>
     case <b>NODE_LIST</b>:
        while (argn) {
            if (setup_args_dup_rest_p(RNODE_LIST(argn)-&amp;nd_head)) {
                return true;
            }
            argn = RNODE_LIST(argn)-&amp;nd_next;
        }
        return false;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/278">
<div class="notes">So we iterate over each element in the list.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>
     case NODE_LIST:
        while (<b>argn</b>) {
            if (setup_args_dup_rest_p(RNODE_LIST(argn)-&amp;nd_head)) {
                return true;
            }
            argn = RNODE_LIST(argn)-&amp;nd_next;
        }
        return false;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/279">
<div class="notes">For each element, we do a recursive function call to see if that element is safe.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>
     case NODE_LIST:
        while (argn) {
            if (<b>setup_args_dup_rest_p(RNODE_LIST(argn)-&amp;nd_head)</b>) {
                return true;
            }
            argn = RNODE_LIST(argn)-&amp;nd_next;
        }
        return false;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/280">
<div class="notes">If the element is not safe, we return true.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>
     case NODE_LIST:
        while (argn) {
            if (setup_args_dup_rest_p(RNODE_LIST(argn)-&amp;nd_head)) {
                <b>return true;</b>
            }
            argn = RNODE_LIST(argn)-&amp;nd_next;
        }
        return false;
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/281">
<div class="notes">If we get through the whole array, and all elements are safe, we return false.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>
     case NODE_LIST:
        while (argn) {
            if (setup_args_dup_rest_p(RNODE_LIST(argn)-&amp;nd_head)) {
                return true;
            }
            argn = RNODE_LIST(argn)-&amp;nd_next;
        }
        <b>return false;</b>
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/282">
<div class="notes">That fixes the Rails method call to not allocate an unnecessary array for the positional splat.</div>

<pre class="sh_ruby" style="font-size: 48px; margin-top: 48px; margin-left: 20px;"><code>
match(*path_or_actions, as:, to:, controller:, action:, on:,
      defaults:, constraints:, anchor:, format:, path:,
      internal:, **mapping, via: [:get, :connect], &amp;block)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/283">
<div class="notes">My challenge to you, is to expand the node types that are considered safe.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      case NODE_LIST:
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/284">
<div class="notes">A good place to start would be to implement support for NODE_HASH, so that literal hashes would not cause unnecessary allocation, as long as all elements of the hash are themselves safe.  There are likely a number of additional node types that are also safe.</div>

<pre class="sh_c" style="font-size: 24px; margin-top: 18px; margin-left: 20px;"><code>static bool
setup_args_dup_rest_p(const NODE *argn)
{
    switch(nd_type(argn)) {
      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_CONST:
      case NODE_COLON3:
      case NODE_INTEGER:
      case NODE_FLOAT:
      case NODE_RATIONAL:
      case NODE_IMAGINARY:
      case NODE_STR:
      case NODE_SYM:
      case NODE_REGX:
      case NODE_SELF:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
      case NODE_LAMBDA:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
        return false;
      case NODE_COLON2:
        return setup_args_dup_rest_p(RNODE_COLON2(argn)-&gt;nd_head);
      case NODE_LIST:
      case <b>NODE_HASH:</b>
      default:
        return true;
    }
}
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/285">
<div class="notes">I would like to finish up this presentation by discussing the remaining implicit allocations in method calls, and whether they could be fixed.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 114px;">Remaining</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 114px;">Implicit</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 530px; left: 114px;">Allocations</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/286">
<div class="notes">Let me start with the caller-side implicit allocations.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 114px;">Caller<span class="red">-</span>Side</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 114px;">Implicit</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 530px; left: 114px;">Allocations</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/287">
<div class="notes">First, having arguments after a positional splat or having multiple positional splats. Ruby's internal method calling API only supports a single positional splat, and does not support arguments after it, so in both cases the caller needs to allocate a new array to combine these arguments.  This is not fixable without major internal changes.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 400px;"><code>
a(*ary, arg)
a(*ary1, *ary2)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/288">
<div class="notes">Second, having literal keywords and a keyword splat, or multiple keyword splats.  Again, Ruby's internal method calling API does not support this.  It supports only literal keywords or only a single keyword splat, so in both of these cases, the caller must allocate a hash and merge these into the hash. This also is not fixable without major internal changes.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 400px;"><code>
a(kw: 1, **hash)
a(**hash1, **hash2)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/289">
<div class="notes">Finally, a positional splat followed by non-static literal keywords.  This currently allocates a hash, even though it does not need to, because Ruby's internal method calling API does not support both a positional splat and literal keywords, only a positional splat and a keyword splat.  So this internally converts the literal keywords to a keyword splat.  I think this case is much easier to fix than the other two cases.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 400px;"><code>
a(*ary1, kw: lvar)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/290">
<div class="notes">Now let me discuss the callee-side implicit allocations.</div>

<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 114px;">Callee<span class="red">-</span>Side</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 114px;">Implicit</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 530px; left: 114px;">Allocations</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/291">
<div class="notes">First, having a named positional splat parameter requires array allocation.  I think this allocation is unavoidable in the general case until we have a generic deoptimization framework, because any method call could result in an eval or access to the binding.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 400px;"><code>
def a(*args)
  # ...
end
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/292">
<div class="notes">Second, a named keyword splat parameter requires hash allocation.  I think this allocation is unavoidable, for the same reason.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 400px;"><code>
def a(**kwargs)
  # ...
end
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/293">
<div class="notes">Finally, calling a method that only accepts positional arguments with literal keywords or a keyword splat.  The callee automatically converts the keywords to a hash, and I think this allocation is also unavoidable, for the same reason.</div>

<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 400px;"><code>
def a(arg)
  # ...
end

a(k: 1)
a(**hash)
</code></pre>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/294">
<div class="notes">I hope you had fun learning about a few of the allocation reduction optimizations in Ruby 3.4.</div>

<h1 class="red" style="font-size: 180px; position: absolute; top: 80px; left: 114px;">Eliminating</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 220px; left: 114px;">Unnecessary</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 373px; left: 114px;">Implicit</h1>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 530px; left: 114px;">Allocations</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/295">
<div class="notes">If you enjoyed this presentation, and want to read more of my thoughts on Ruby programming, please consider picking up a copy of Polished Ruby Programming.</div>

<p><img src="./file/polished-ruby-programming-cover.png" style="position: absolute; top: 20px; left: 548px; height: 1031px; width: 822px;"></p>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/296">
<div class="notes">That concludes my presentation.  I would like to thank all of you for listening to me.</div>

<h1 class="blue" style="font-size: 250px; position: absolute; top: 432px; left: 350px;">
<span class="red">Thank You</span>!</h1>

</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/297">
<div class="notes">If you have any questions, now is the time to ask them.</div>

<h1 class="blue" style="font-size: 250px; position: absolute; top: 432px; left: 350px;">Questions<span class="red">?</span>
</h1>
</div>
</div>
</body></html>
</div>

</body>
</html>
